#!/bin/bash

# build_safe.sh
#
# Script mejorado para compilar, gestionar y ejecutar mcpelauncher.
#
# Funcionalidades:
# - Compilar los componentes con manejo seguro del conflicto zlib/zlib-ng.
# - Desinstalar los componentes y limpiar residuos.
# - Añadir y gestionar múltiples versiones del juego.
# - Listar y ejecutar versiones específicas.
# - Ejecutar el juego (acción por defecto).

# --- Configuración de Seguridad y Errores ---
set -e
set -u
set -o pipefail

# --- Variables Globales ---
readonly MCPARCH_ICON_SVG='<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg version="1.1" width="512" height="512" viewBox="0 0 512 512" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><defs id="defs1" /><path id="bg1" fill="#81563a" d="M 0,0 H 512 V 512 H 0 Z" /><path id="bg2" fill="#61b441" d="M 0,0 V 128 H 64 V 64 H 128 V 128 H 256 V 192 H 320 V 128 H 384 V 64 H 448 V 192 H 512 V 0 Z" /><rect id="rect1" width="64" height="64" x="0" y="0" fill="#86d562" /><rect id="rect2" width="64" height="64" x="64" y="0" fill="#52a535" /><rect id="rect3" width="64" height="64" x="128" y="0" fill="#6cc349" /><rect id="rect4" width="64" height="64" x="192" y="0" fill="#86d562" /><rect id="rect5" width="64" height="64" x="256" y="0" fill="#6cc349" /><rect id="rect6" width="64" height="64" x="320" y="0" fill="#52a535" /><rect id="rect7" width="64" height="64" x="384" y="0" fill="#6cc349" /><rect id="rect8" width="64" height="64" x="448" y="0" fill="#52a535" /><rect id="rect9" width="64" height="64" x="0" y="64" fill="#52a535" /><rect id="rect10" width="64" height="64" x="64" y="64" fill="#66412c" /><rect id="rect11" width="64" height="64" x="128" y="64" fill="#52a535" /><rect id="rect12" width="64" height="64" x="192" y="64" fill="#3c8527" /><rect id="rect13" width="64" height="64" x="256" y="64" fill="#52a535" /><rect id="rect14" width="64" height="64" x="320" y="64" fill="#6cc349" /><rect id="rect15" width="64" height="64" x="384" y="64" fill="#66412c" /><rect id="rect16" width="64" height="64" x="448" y="64" fill="#6cc349" /><rect id="rect17" width="64" height="64" x="0" y="128" fill="#66412c" /><rect id="rect18" width="64" height="64" x="64" y="128" fill="#998f8b" /><rect id="rect19" width="64" height="64" x="128" y="128" fill="#66412c" /><rect id="rect20" width="64" height="64" x="192" y="128" fill="#66412c" /><rect id="rect21" width="64" height="64" x="256" y="128" fill="#6cc349" /><rect id="rect22" width="64" height="64" x="320" y="128" fill="#66412c" /><rect id="rect23" width="64" height="64" x="384" y="128" fill="#805539" /><rect id="rect24" width="64" height="64" x="448" y="128" fill="#52a535" /><rect id="rect25" width="64" height="64" x="0" y="192" fill="#976746" /><rect id="rect26" width="64" height="64" x="64" y="192" fill="#805539" /><rect id="rect27" width="64" height="64" x="128" y="192" fill="#976746" /><rect id="rect28" width="64" height="64" x="192" y="192" fill="#ad7a54" /><rect id="rect29" width="64" height="64" x="256" y="192" fill="#66412c" /><rect id="rect30" width="64" height="64" x="320" y="192" fill="#805539" /><rect id="rect31" width="64" height="64" x="384" y="192" fill="#976746" /><rect id="rect32" width="64" height="64" x="448" y="192" fill="#66412c" /><rect id="rect33" width="64" height="64" x="0" y="256" fill="#805539" /><rect id="rect34" width="64" height="64" x="64" y="256" fill="#66412c" /><rect id="rect35" width="64" height="64" x="128" y="256" fill="#66412c" /><rect id="rect36" width="64" height="64" x="192" y="256" fill="#976746" /><rect id="rect37" width="64" height="64" x="256" y="256" fill="#805539" /><rect id="rect38" width="64" height="64" x="320" y="256" fill="#ad7a54" /><rect id="rect39" width="64" height="64" x="384" y="256" fill="#66412c" /><rect id="rect40" width="64" height="64" x="448" y="256" fill="#66412c" /><rect id="rect41" width="64" height="64" x="0" y="320" fill="#ad7a54" /><rect id="rect42" width="64" height="64" x="64" y="320" fill="#805539" /><rect id="rect43" width="64" height="64" x="128" y="320" fill="#66412c" /><rect id="rect44" width="64" height="64" x="192" y="320" fill="#66412c" /><rect id="rect45" width="64" height="64" x="256" y="320" fill="#998f8b" /><rect id="rect46" width="64" height="64" x="320" y="320" fill="#805539" /><rect id="rect47" width="64" height="64" x="384" y="320" fill="#976746" /><rect id="rect48" width="64" height="64" x="448" y="320" fill="#805539" /><rect id="rect49" width="64" height="64" x="0" y="384" fill="#805539" /><rect id="rect50" width="64" height="64" x="64" y="384" fill="#976746" /><rect id="rect51" width="64" height="64" x="128" y="384" fill="#66412c" /><rect id="rect52" width="64" height="64" x="192" y="384" fill="#ad7a54" /><rect id="rect53" width="64" height="64" x="256" y="384" fill="#976746" /><rect id="rect54" width="64" height="64" x="320" y="384" fill="#ad7a54" /><rect id="rect55" width="64" height="64" x="384" y="384" fill="#805539" /><rect id="rect56" width="64" height="64" x="448" y="384" fill="#976746" /><rect id="rect57" width="64" height="64" x="0" y="448" fill="#805539" /><rect id="rect58" width="64" height="64" x="64" y="448" fill="#805539" /><rect id="rect59" width="64" height="64" x="128" y="448" fill="#998f8b" /><rect id="rect60" width="64" height="64" x="192" y="448" fill="#805539" /><rect id="rect61" width="64" height="64" x="256" y="448" fill="#805539" /><rect id="rect62" width="64" height="64" x="320" y="448" fill="#976746" /><rect id="rect63" width="64" height="64" x="384" y="448" fill="#66412c" /><rect id="rect64" width="64" height="64" x="448" y="448" fill="#ad7a54" /><rect id="rect65" width="64" height="4.4" x="384" y="64" fill="#503120" /><rect id="rect66" width="64" height="4.4" x="320" y="128" fill="#503120" /><rect id="rect67" width="64" height="4.4" x="128" y="128" fill="#503120" /><rect id="rect68" width="64" height="4.4" x="192" y="128" fill="#503120" /><rect id="rect69" width="64" height="4.4" x="64" y="64" fill="#503120" /><rect id="rect70" width="64" height="4.4" x="0" y="128" fill="#503120" /><rect id="rect71" width="64" height="4.4" x="64" y="192" fill="#65402a" /><rect id="rect72" width="64" height="4.4" x="256" y="192" fill="#503120" /><rect id="rect73" width="64" height="4.4" x="448" y="192" fill="#503120" /><rect id="rect74" width="64" height="4.4" x="384" y="256" fill="#503120" /><rect id="rect75" width="64" height="4.4" x="192" y="320" fill="#503120" /><rect id="rect76" width="64" height="4.4" x="128" y="256" fill="#503120" /><rect id="rect77" width="64" height="4.4" x="0" y="256" fill="#65402a" /><rect id="rect78" width="64" height="4.4" x="256" y="384" fill="#764d34" /><rect id="rect79" width="64" height="4.4" x="0" y="448" fill="#503120" /><rect id="rect80" width="64" height="4.4" x="320" y="448" fill="#764d34" /><rect id="rect81" width="64" height="4.4" x="320" y="320" fill="#65402a" /><rect id="rect82" width="64" height="4.4" x="384" y="384" fill="#65402a" /></svg>'
readonly SCRIPT_CWD=$(pwd)
readonly LOG_DIR="$SCRIPT_CWD/logs"
readonly ROOT_SOURCE="$HOME/src"
readonly EXTRACTOR_SRC_DIR="mcpelauncher-extract-src"
readonly LAUNCHER_SRC_DIR="mcpelauncher-src"
readonly ZLIB_BUILD_DIR="$ROOT_SOURCE/zlib_build"
readonly ZLIB_LIB_PATH="$ZLIB_BUILD_DIR/lib/libz.a"
readonly ZLIB_INCLUDE_PATH="$ZLIB_BUILD_DIR/include"

# --- NUEVO: Sistema de gestión de versiones y repositorios ---
readonly CONFIG_DIR="$HOME/.config/mcparch"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly VERSIONS_DB_DIR="$CONFIG_DIR/versions_db"
readonly REPOSITORIES_CONF_FILE="$CONFIG_DIR/repositories.conf"
GAME_DIR=""

# Variables de configuración (cargadas desde el archivo)
DEFAULT_VERSION_ID=""
CLEANUP_AFTER_BUILD=false


# Variables para desinstalación
readonly LAUNCHER_BUILD_DIR="$ROOT_SOURCE/mcpelauncher-src/build"
readonly EXTRACTOR_BUILD_DIR="$ROOT_SOURCE/mcpelauncher-extract-src/build"
readonly DESKTOP_FILE="$HOME/.local/share/applications/MCPE-LAUNCHER.desktop"
readonly ICON_FILE="$HOME/.local/share/icons/hicolor/scalable/apps/MCPE-LAUNCHER.svg"
readonly GAME_DATA_DIR="$HOME/.local/share/mcpelauncher"


# --- Funciones de Utilidad (Log y Colores) ---
function print_info() {
    echo -e "\e[34m[INFO]\e[0m $1"
}

function print_success() {
    echo -e "\e[32m[SUCCESS]\e[0m $1"
}

function print_warning() {
    echo -e "\e[33m[WARNING]\e[0m $1"
}

function print_error() {
    echo -e "\e[31m[ERROR]\e[0m $1" >&2
}

function run_as_root() {
    # Si ya es root, ejecutar directamente
    if [ "$(id -u)" -eq 0 ]; then
        "$@"
    # Si 'sudo' existe, usarlo
    elif command -v sudo &> /dev/null; then
        print_info "Se necesitan privilegios de administrador (usando sudo): '$*'"
        sudo "$@"
    # Si no, si 'doas' existe, usarlo
    elif command -v doas &> /dev/null; then
        print_info "Se necesitan privilegios de administrador (usando doas): '$*'"
        doas "$@"
    # Si no existe ninguno de los dos
    else
        print_error "Comando 'sudo' o 'doas' no encontrado. Se necesitan privilegios de administrador."
        exit 1
    fi
}

# --- NUEVO: Funciones de Spinner para feedback visual ---
SPINNER_PID=0
function start_spinner() {
    # Ocultar cursor
    printf "\e[?25l"
    (
        local spin='|/-\'
        local i=0
        while true; do
            i=$(( (i+1) %4 ))
            printf "\r\e[34mConsultando...\e[0m %s" "${spin:$i:1}"
            sleep 0.1
        done
    ) &
    SPINNER_PID=$!
    # Asegurarse de que el spinner se detenga y el cursor se restaure si el script se interrumpe
    trap 'stop_spinner; exit 1' INT TERM
}

function stop_spinner() {
    if [ "$SPINNER_PID" -ne 0 ]; then
        kill "$SPINNER_PID" &> /dev/null
        wait "$SPINNER_PID" 2>/dev/null || true # Evitar que set -e termine el script
    fi
    # Limpiar línea y restaurar cursor
    printf "\r\e[K\e[?25h"
    SPINNER_PID=0
    # Limpiar el trap
    trap - INT TERM
}



function check_dependencies() {
    print_info "Verificando dependencias de compilación y ejecución..."
    # Se añade jq, crucial para el nuevo sistema de repositorios.
    local required_cmds=("git" "cmake" "make" "clang" "curl" "pkg-config" "jq")
    local required_libs=("libzip" "openssl" "Qt5WebChannel" "Qt5Positioning" "xi") # Librerías a verificar con pkg-config
    local missing_deps=()

    for cmd in "${required_cmds[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    # Solo verificar librerías si pkg-config está instalado
    if command -v "pkg-config" &> /dev/null; then
        for lib in "${required_libs[@]}"; do
            if ! pkg-config --exists "$lib"; then
                # El nombre del paquete de desarrollo suele ser diferente
                # Se informa al usuario del paquete conceptual que falta
                missing_deps+=("$lib-devel")
            fi
        done
    fi

    if [ ${#missing_deps[@]} -eq 0 ]; then
        print_success "Todas las dependencias están presentes."
        return 0
    fi

    print_error "Faltan dependencias esenciales: ${missing_deps[*]}"
    print_info "Por favor, instala estas herramientas usando el gestor de paquetes de tu sistema."
    print_info "Si no estás seguro de cómo hacerlo, puedes usar la opción '--install-deps' para que este script intente hacerlo por ti."
    exit 1
}

function do_install_deps() {
    print_info "Intentando instalar dependencias de compilación automáticamente..."

    local PKG_MANAGER=""
    if command -v pacman &> /dev/null; then PKG_MANAGER="pacman";
    elif command -v apt-get &> /dev/null; then PKG_MANAGER="apt";
    elif command -v dnf &> /dev/null; then PKG_MANAGER="dnf";
    elif command -v xbps-install &> /dev/null; then PKG_MANAGER="xbps";
    elif command -v zypper &> /dev/null; then PKG_MANAGER="zypper";
    else
        print_error "No se pudo detectar un gestor de paquetes compatible (apt, pacman, dnf, xbps, zypper)."
        print_error "Por favor, instala manualmente las dependencias completas."
        exit 1
    fi

    print_info "Gestor de paquetes detectado: $PKG_MANAGER"

    local packages=""
    case "$PKG_MANAGER" in
        pacman)
            print_info "En sistemas Arch, se recomienda tener 'base-devel' instalado."
            packages="base-devel git cmake make clang curl pkg-config libzip qt5-base qt5-webengine qt5-location qt5-declarative qt5-quickcontrols2 ca-certificates libpng libx11 libxi systemd libevdev mesa alsa-lib libpulse libxtst openssl qt5-svg"
            ;; 
        apt)
            packages="build-essential git cmake make clang curl pkg-config libzip-dev ca-certificates libc6-dev libpng-dev libx11-dev libxi-dev libcurl4-openssl-dev libsystemd-dev libevdev-dev libegl1-mesa-dev libasound2-dev libpulse-dev libxtst-dev libssl-dev qtbase5-dev qtwebengine5-dev qtdeclarative5-dev libqt5svg5-dev qtquickcontrols2-5-dev libqt5quickcontrols2-5 qttools5-dev-tools libudev-dev libstdc++-12-dev qml-module-qtquick-controls qml-module-qtquick-layouts qml-module-qtquick-dialogs qml-module-qtquick-window2 qml-module-qtwebengine qml-module-org-kde-qqc2desktopstyle"
            ;; 
        dnf)
            print_info "En sistemas Fedora, se recomienda el grupo 'Development Tools'."
            packages="git cmake make clang curl pkg-config libzip-devel ca-certificates libstdc++ glibc-devel libpng-devel libX11-devel libXi-devel libcurl-devel systemd-devel libevdev-devel mesa-libEGL-devel alsa-lib-devel pulseaudio-libs-devel mesa-dri-drivers libXtst-devel openssl-devel qt5-qtbase-devel qt5-qtwebengine-devel qt5-qtdeclarative-devel qt5-qtsvg-devel qt5-qtquickcontrols qt5-qtquickcontrols2"
            ;; 
        xbps)
            # La lista de xbps ya era bastante completa, la mantenemos y aseguramos que no falte nada clave.
            packages="git cmake make clang curl pkg-config libzip-devel openssl-devel libX11-devel wayland-devel alsa-lib-devel libXext-devel libXi-devel libpng-devel MesaLib-devel libevdev-devel qt5-devel qt5-webengine-devel qt5-webchannel-devel qt5-location-devel qt5-declarative-devel qt5-quickcontrols2-devel libatomic-devel qt5-quickcontrols alsa-plugins"
            ;; 
        zypper)
            # Lista similar a DNF para OpenSUSE
            packages="git cmake make clang curl pkg-config libzip-devel ca-certificates libstdc++6-devel-gcc13 glibc-devel libpng16-devel libX11-devel libXi-devel libcurl-devel systemd-devel libevdev-devel Mesa-libEGL-devel alsa-devel pulseaudio-devel libXtst-devel libopenssl-devel"
            ;; 
        *)
            # Fallback genérico
            packages="git cmake make clang curl pkg-config"
            ;; 
    esac

    local install_command=""
    case "$PKG_MANAGER" in
        pacman) install_command="sudo pacman -S --noconfirm --needed $packages" ;; 
        apt) install_command="sudo apt-get install -y $packages" ;; 
        dnf) install_command="sudo dnf install -y $packages" ;; 
        xbps) install_command="sudo xbps-install -S -y $packages" ;; 
        zypper) install_command="sudo zypper install -y $packages" ;; 
    esac

    echo
    print_info "Se ejecutará el siguiente comando:"
    echo "  $install_command"
    echo
    read -p "¿Deseas continuar? (s/n): " choice
    case "$choice" in
        [Ss]*) 
            print_info "Instalando dependencias..."
            if $install_command; then
                print_success "Dependencias instaladas correctamente."
                print_info "Puedes proceder a compilar con la opción '--build'."
            else
                print_error "La instalación de dependencias falló."
                print_error "Por favor, revisa los errores e inténtalo manually."
                exit 1
            fi
            ;; 
        *)
            print_error "Instalación cancelada por el usuario."
            exit 1
            ;; 
    esac
}

function compile_static_zlib() {
    if [ -f "$ZLIB_LIB_PATH" ]; then
        print_success "Librería zlib estática ya compilada. Omitiendo."
        return
    fi

    print_info "Compilando zlib estático para evitar conflictos con zlib-ng..."
    mkdir -p "$ZLIB_BUILD_DIR"
    cd "$ROOT_SOURCE"

    local zlib_ver="1.3.1"
    local zlib_tar="zlib-${zlib_ver}.tar.gz"
    local zlib_src_dir="zlib-${zlib_ver}"

    if [ ! -f "$zlib_tar" ]; then
        print_info "Descargando zlib v${zlib_ver}..."
        curl -L "https://zlib.net/${zlib_tar}" -o "$zlib_tar"
    fi

    if [ -d "$zlib_src_dir" ]; then
        rm -rf "$zlib_src_dir"
    fi

    print_info "Extrayendo zlib..."
    tar -xzf "$zlib_tar"
    cd "$zlib_src_dir"

    print_info "Configurando y compilando zlib (estático)..."
    export CC=clang # Forzar el uso de clang
    ./configure --prefix="$ZLIB_BUILD_DIR" --static &> "$LOG_DIR/zlib_configure.log"
    make &> "$LOG_DIR/zlib_build.log"
    make install &> "$LOG_DIR/zlib_install.log"

    cd "$ROOT_SOURCE"
    print_success "zlib estático compilado e instalado en '$ZLIB_BUILD_DIR'."
}

function patch_cmake_version() {
    print_info "Actualizando la versión mínima de CMake en los archivos CMakeLists.txt..."
    find . -type f -name "CMakeLists.txt" -not -path "./sdl3/*" -not -path "./imgui/*" -exec sed -i 's/cmake_minimum_required *(VERSION *[0-9.]*)/cmake_minimum_required(VERSION 3.5)/g' {} + 
    print_success "Versión de CMake actualizada."
}

function compile_extractor() {
    print_info "Verificando instalación de mcpelauncher-extract..."
    if command -v mcpelauncher-extract &> /dev/null; then
        print_success "mcpelauncher-extract ya está instalado. Omitiendo compilación."
        return
    fi

    print_info "Iniciando compilación de mcpelauncher-extract..."
    if [ -d "$EXTRACTOR_SRC_DIR" ]; then
        print_info "Directorio '$EXTRACTOR_SRC_DIR' encontrado. Actualizando..."
        cd "$EXTRACTOR_SRC_DIR"
        git pull &> "$LOG_DIR/extractor_git.log"
    else
        print_info "Clonando mcpelauncher-extract... (ver '$LOG_DIR/extractor_git.log')"
        git clone https://github.com/minecraft-linux/mcpelauncher-extract.git -b ng "$EXTRACTOR_SRC_DIR" &> "$LOG_DIR/extractor_git.log"
        cd "$EXTRACTOR_SRC_DIR"
    fi

    print_info "Configurando con CMake... (ver '$LOG_DIR/extractor_configure.log')"
    cmake -B build -S . -DCMAKE_POLICY_VERSION_MINIMUM=3.5 &> "$LOG_DIR/extractor_configure.log"

    print_info "Compilando... (ver '$LOG_DIR/extractor_build.log')"
    cmake --build build --parallel "$(nproc)" &> "$LOG_DIR/extractor_build.log"

    print_info "Instalando mcpelauncher-extract... (ver '$LOG_DIR/extractor_install.log')"
    run_as_root cmake --install build &> "$LOG_DIR/extractor_install.log"

    # NUEVO: Guardar el manifiesto de instalación para una desinstalación robusta
    local manifest_path="build/install_manifest.txt"
    if [ -f "$manifest_path" ]; then
        cp "$manifest_path" "$CONFIG_DIR/extractor_install_manifest.txt"
        print_info "Manifiesto de instalación para 'extractor' guardado."
    fi

    cd ..
    print_success "mcpelauncher-extract compilado e instalado."
}

function compile_launcher() {
    print_info "Verificando instalación de mcpelauncher-client..."
    if command -v mcpelauncher-client &> /dev/null; then
        print_success "mcpelauncher-client ya está instalado. Omitiendo compilación."
        return
    fi

    compile_static_zlib
    cd "$ROOT_SOURCE"

    print_info "Iniciando compilación de mcpelauncher-client..."
    if [ -d "$LAUNCHER_SRC_DIR" ]; then
        print_info "Directorio '$LAUNCHER_SRC_DIR' encontrado. Actualizando..."
        cd "$LAUNCHER_SRC_DIR"
        git pull --recurse-submodules &> "$LOG_DIR/launcher_git.log"
    else
        print_info "Clonando mcpelauncher-manifest (esto puede tardar)... (ver '$LOG_DIR/launcher_git.log')"
        git clone --recursive https://github.com/minecraft-linux/mcpelauncher-manifest.git "$LAUNCHER_SRC_DIR" &> "$LOG_DIR/launcher_git.log"
        cd "$LAUNCHER_SRC_DIR"
    fi

    patch_cmake_version

    print_info "Configurando con CMake... (ver '$LOG_DIR/launcher_configure.log')"
    cmake -B build -S . \
          -DCMAKE_C_COMPILER=clang \
          -DCMAKE_CXX_COMPILER=clang++ \
          -DCMAKE_BUILD_TYPE=RelWithDebInfo \
          -DENABLE_DEV_PATHS=OFF \
          -DZLIB_LIBRARY="$ZLIB_LIB_PATH" \
          -DZLIB_INCLUDE_DIR="$ZLIB_INCLUDE_PATH" \
          -Wno-dev &> "$LOG_DIR/launcher_configure.log"

    print_info "Compilando (esto puede tardar mucho)... (ver '$LOG_DIR/launcher_build.log')"
    cmake --build build --parallel "$(nproc)" &> "$LOG_DIR/launcher_build.log"

    print_info "Instalando mcpelauncher-client... (ver '$LOG_DIR/launcher_install.log')"
    run_as_root cmake --install build &> "$LOG_DIR/launcher_install.log"

    # NUEVO: Guardar el manifiesto de instalación para una desinstalación robusta
    local manifest_path="build/install_manifest.txt"
    if [ -f "$manifest_path" ]; then
        cp "$manifest_path" "$CONFIG_DIR/launcher_install_manifest.txt"
        print_info "Manifiesto de instalación para 'launcher' guardado."
    fi

    cd ..
    print_success "mcpelauncher-client compilado e instalado."
}


# --- NUEVO: Funciones de Gestión de Versiones ---

function get_apk_path() {
    local apk_path_arg="${1-}"
    local apk_path=""

    # Fase 1: Validar el argumento si se proporcionó.
    if [ -n "$apk_path_arg" ]; then
        # Expandir la tilde (~) si está al principio de la ruta.
        apk_path="${apk_path_arg/#\~/$HOME}"
        if [ -f "$apk_path" ]; then
            print_info "APK encontrado en la ruta de argumento: $apk_path" >&2
            echo "$apk_path"
            return 0
        else
            print_error "Archivo no encontrado en la ruta proporcionada: '$apk_path_arg'"
            print_info "Se procederá con el modo interactivo." >&2
        fi
    fi

    # Fase 2: Modo interactivo si no se proporcionó un argumento válido.
    while true; do
        read -p "Por favor, ingresa la ruta completa al archivo .apk de Minecraft (o deja en blanco para cancelar): " apk_path
        if [ -z "$apk_path" ]; then
            # El usuario no ingresó nada, devolvemos una cadena vacía para indicar cancelación.
            echo ""
            break
        fi
        
        # Expandir la tilde (~)
        apk_path="${apk_path/#\~/$HOME}"
        
        if [ ! -f "$apk_path" ]; then
            print_error "Archivo no encontrado en '$apk_path'. Asegúrate de que la ruta es correcta."
        else
            echo "$apk_path"
            break
        fi
    done
}

function do_add_version() {
    local apk_path_arg="${1-}"
    local preselected_id="${2-}"

    print_info "Añadiendo una nueva versión de Minecraft..."
    # MEJORA: Usar ruta absoluta para no depender del PATH
    local extractor_bin="/usr/local/bin/mcpelauncher-extract"
    if ! [ -x "$extractor_bin" ]; then
        
        print_error "Ejecutable '$extractor_bin' no encontrado o no es ejecutable."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        exit 1
    fi

    local apk_path
    apk_path=$(get_apk_path "$apk_path_arg") # Pasamos el posible argumento (ruta del apk)
    # Si get_apk_path no devuelve nada (ej. el usuario cancela), salimos.
    if [ -z "$apk_path" ]; then
        print_info "Operación de añadir versión cancelada."
        exit 1
    fi

    local version_id
    if [ -n "$preselected_id" ]; then
        version_id="$preselected_id"
        print_info "Usando ID del repositorio: '$version_id'"
        if [ -f "$VERSIONS_DB_DIR/$version_id" ]; then
            print_error "El ID de versión '$version_id' ya existe en tu sistema."
            print_info "Si deseas reemplazarla, primero elimínala con: mcparch --remove '$version_id'"
            exit 1
        fi
    else
        while true; do
            read -p "Ingresa un ID único para esta versión (ej: 1.20.x.x): " version_id
            if [ -z "$version_id" ]; then
                print_error "El ID no puede estar vacío."
                continue
            fi
            if [ -f "$VERSIONS_DB_DIR/$version_id" ]; then
                print_error "El ID '$version_id' ya existe. Por favor, elige otro."
            else
                break
            fi
        done
    fi

    local target_dir="$HOME/.local/share/mcpelauncher/versions/$version_id"
    if [ -d "$target_dir" ]; then
        print_warning "El directorio de destino '$target_dir' ya existe."
        read -p "¿Deseas sobreescribirlo? (s/n): " choice
        case "$choice" in
            [Ss]*) rm -rf "$target_dir" ;; 
            *) print_info "Operación cancelada."; exit 0 ;; 
        esac
    fi

    print_info "Extrayendo archivos a '$target_dir'..."
    mkdir -p "$target_dir"

    # MEJORA: Capturar la salida del extractor para detectar errores de incompatibilidad.
    local extraction_output
    # Redirigimos stderr a stdout para capturarlo todo en una variable.
    extraction_output=$("$extractor_bin" "$apk_path" "$target_dir" 2>&1)

    # Comprobar si la extracción falló porque el APK es incompatible (ej. ARM en x86)
    if echo "$extraction_output" | grep -q "libminecraftpe.so was not extracted"; then
        print_error "¡Extracción fallida! El APK proporcionado no es compatible."
        print_warning "El script requiere un APK para la arquitectura x86 o x86_64."
        print_warning "El archivo que usaste es probablemente para ARM (móviles)."
        print_info "Limpiando el directorio de la versión fallida..."
        rm -rf "$target_dir"
        print_success "Limpieza completada. No se ha añadido ninguna versión."
        exit 1 # Salir con error para evitar que el script continúe.
    fi

    # Si la extracción fue exitosa, mostrar la salida para información.
    # Esto mantiene la retroalimentación original como el "Done!".
    echo "$extraction_output"

    # Guardar en la base de datos de versiones
    echo "$target_dir" > "$VERSIONS_DB_DIR/$version_id"
    print_success "Versión '$version_id' añadida y registrada correctamente."
}

function do_add_gui() {
    print_info "Iniciando la adición de versión con GUI..."

    # 1. Comprobar si zenity está disponible, ya que es el estándar de facto para scripts en GTK.
    if ! command -v zenity &> /dev/null; then
        print_error "El comando 'zenity' no fue encontrado."
        print_info "Esta función requiere 'zenity' para mostrar el selector de archivos gráfico."
        print_info "Por favor, instálalo usando el gestor de paquetes de tu sistema (ej: 'sudo pacman -S zenity')."
        exit 1
    fi

    # 2. Abrir el selector de archivos. Redirigimos stderr para ocultar mensajes de GTK.
    print_info "Abriendo el selector de archivos gráfico..."
    local apk_path
    apk_path=$(zenity --file-selection --title="Selecciona el archivo .apk de Minecraft" --file-filter="*.apk" 2>/dev/null)

    # 3. Comprobar si el usuario canceló la selección.
    if [ -z "$apk_path" ]; then
        print_info "Operación cancelada por el usuario."
        exit 0
    fi

    # 4. Llamar a la función 'add' existente con la ruta obtenida.
    # Esto reutiliza toda la lógica de validación, extracción y limpieza.
    print_info "Archivo seleccionado: $apk_path"
    do_add_version "$apk_path"
}

function do_list_versions() {
    print_info "Versiones de Minecraft disponibles:"
    if [ -z "$(ls -A "$VERSIONS_DB_DIR")" ]; then
        print_warning "No hay versiones instaladas."
        print_info "Usa la opción '--add' para añadir una."
        return 1
    fi

    # Imprimir una lista numerada
    local i=1
    for version_file in "$VERSIONS_DB_DIR"/*; do
        echo "  $i. $(basename "$version_file")"
        i=$((i + 1))
    done
    return 0
}

function load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

function ensure_config_exists() {
    if [ ! -f "$CONFIG_FILE" ]; then
        print_info "Creando archivo de configuración por primera vez..."
        echo "# Archivo de configuración para MCPARCH" > "$CONFIG_FILE"
        echo "DEFAULT_VERSION_ID=\"\"" >> "$CONFIG_FILE"
        print_success "Archivo de configuración creado en '$CONFIG_FILE'."
    fi

    if [ ! -f "$REPOSITORIES_CONF_FILE" ]; then
        print_info "Creando archivo de repositorios por primera vez..."
        touch "$REPOSITORIES_CONF_FILE"
        print_success "Archivo de repositorios creado en '$REPOSITORIES_CONF_FILE'."
        print_info "Añade tu primer repositorio con: mcparch --add-repo <URL>"
    fi

    # NUEVO: Asegurar que la infraestructura de plugins exista
    if [ ! -d "$CONFIG_DIR/plugins" ]; then
        print_info "Creando directorio de plugins..."
        mkdir -p "$CONFIG_DIR/plugins"
        print_success "Directorio de plugins creado en '$CONFIG_DIR/plugins'."
    fi
    if [ ! -f "$CONFIG_DIR/plugins.conf" ]; then
        touch "$CONFIG_DIR/plugins.conf"
    fi
}

function do_set_default_version() {
    local version_id="$1"
    local version_file="$VERSIONS_DB_DIR/$version_id"

    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    # Usamos sed para reemplazar el valor de forma segura
    sed -i "s/^DEFAULT_VERSION_ID=.*/DEFAULT_VERSION_ID=\"$version_id\"/" "$CONFIG_FILE"
    print_success "Versión por defecto establecida a '$version_id'."
}

function do_remove_version() {
    local version_id="$1"
    local version_db_file="$VERSIONS_DB_DIR/$version_id"

    if [ ! -f "$version_db_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    local game_path
    game_path=$(cat "$version_db_file")

    print_warning "ADVERTENCIA: Estás a punto de eliminar permanentemente la versión '$version_id'."
    print_warning "Esto borrará los datos del juego en '$game_path'."
    read -p "¿Estás seguro de que deseas continuar? (s/n): " choice
    case "$choice" in
        [Ss]*) 
            print_info "Eliminando versión '$version_id'..."

            # Eliminar el directorio del juego
            if [ -d "$game_path" ]; then
                rm -rf "$game_path"
                print_success "Directorio de datos del juego eliminado."
            else
                print_warning "No se encontró el directorio de datos del juego. Puede que ya haya sido eliminado."
            fi

            # Eliminar el archivo de la base de datos
            rm -f "$version_db_file"
            print_success "Registro de la versión eliminado."

            # Comprobar si era la versión por defecto
            if [ "$DEFAULT_VERSION_ID" = "$version_id" ]; then
                print_info "La versión eliminada era la predeterminada. Limpiando configuración..."
                sed -i "s/^DEFAULT_VERSION_ID=.*/DEFAULT_VERSION_ID=\"\"/" "$CONFIG_FILE"
                print_success "La versión por defecto ha sido reiniciada."
            fi

            print_success "Versión '$version_id' eliminada correctamente."
            ;; 
        *) 
            print_info "Operación cancelada."
            ;; 
    esac
}

function do_rename_id() {
    local old_id="$1"
    local new_id="$2"
    local old_version_db_file="$VERSIONS_DB_DIR/$old_id"
    local new_version_db_file="$VERSIONS_DB_DIR/$new_id"

    # 1. Validaciones
    if [ ! -f "$old_version_db_file" ]; then
        print_error "El ID de versión '$old_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    if [ -f "$new_version_db_file" ]; then
        print_error "El nuevo ID de versión '$new_id' ya existe. Por favor, elige otro."
        exit 1
    fi

    if [ "$old_id" = "$new_id" ]; then
        print_info "El ID antiguo y el nuevo son iguales. No se realizó ningún cambio."
        exit 0
    fi

    print_info "Renombrando ID de '$old_id' a '$new_id'வோம்..."

    # 2. Renombrar archivo de la base de datos
    mv "$old_version_db_file" "$new_version_db_file"
    print_success "Registro de la versión renombrado."

    # 3. Comprobar si era la versión por defecto
    if [ "$DEFAULT_VERSION_ID" = "$old_id" ]; then
        print_info "La versión renombrada era la predeterminada. Actualizando configuración..."
        sed -i "s/^DEFAULT_VERSION_ID=.*/DEFAULT_VERSION_ID=\"$new_id\"/" "$CONFIG_FILE"
        print_success "La versión por defecto ha sido actualizada a '$new_id'."
    fi

    # 4. Actualizar acceso directo si existe
    local desktop_dir="$HOME/.local/share/applications"
    local old_shortcut_file="$desktop_dir/mcparch-$old_id.desktop"
    local new_shortcut_file="$desktop_dir/mcparch-$new_id.desktop"

    if [ -f "$old_shortcut_file" ]; then
        print_info "Actualizando y recreando el acceso directo..."

        # Leer el contenido del archivo original
        local content
        content=$(cat "$old_shortcut_file")

        # Reemplazar de forma específica para evitar corrupción
        local new_content
        new_content="${content/Name=Minecraft PE ($old_id)/Name=Minecraft PE ($new_id)}"
        new_content="${new_content/--run \"$old_id\"/--run \"$new_id\"}"

        # Escribir el contenido modificado en el nuevo archivo
        echo "$new_content" > "$new_shortcut_file"

        # Eliminar el archivo antiguo si los nombres son diferentes
        if [ "$old_shortcut_file" != "$new_shortcut_file" ]; then
            rm "$old_shortcut_file"
        fi

        print_success "Acceso directo actualizado a '$new_shortcut_file'."
    fi

    print_success "¡ID de versión renombrado correctamente de '$old_id' a '$new_id'!"
}



# --- Funciones de Juego (Actualizadas) ---

function run_game() {
    local game_path="$1"
    if [ -z "$game_path" ] || [ ! -d "$game_path" ]; then
        print_error "La ruta del juego no es válida."
        exit 1
    fi
    print_info "Iniciando Minecraft desde '$game_path'..."
    # Añadir /usr/local/bin al PATH para asegurar que mcpelauncher-client
    # pueda encontrar mcpelauncher-webview, especialmente al lanzar desde un acceso directo.
    export PATH="/usr/local/bin:$PATH"
    /usr/local/bin/mcpelauncher-client -dg "$game_path" || true
    print_success "El juego se ha cerrado."
}


# --- NUEVO: Funciones de Gestión de Repositorios y Binarios ---

function do_add_repo() {
    local url="$1"
    if [ -z "$url" ]; then
        print_error "Se requiere una URL al archivo 'sources.json' del repositorio."
        print_info "Uso: $0 --add-repo <URL>"
        exit 1
    fi

    print_info "Validando y añadiendo repositorio desde: $url"

    local temp_json
    temp_json=$(mktemp)
    trap 'rm -f "$temp_json"' RETURN

    print_info "Descargando y validando el repositorio..."
    if ! curl -L -f -s -H "Cache-Control: no-cache" -H "Pragma: no-cache" "$url" -o "$temp_json"; then
        print_error "No se pudo descargar el archivo desde la URL."
        print_warning "Verifica que la URL es correcta y que tu conexión a internet funciona."
        exit 1
    fi

    # Validar que es un JSON y extraer el nombre
    if ! jq -e '.repository.name' "$temp_json" > /dev/null; then
        print_error "El archivo JSON no es válido o no contiene el campo '.repository.name'."
        print_info "Asegúrate de que la URL apunta a un archivo 'sources.json' con el formato correcto."
        exit 1
    fi

    local repo_name
    repo_name=$(jq -r '.repository.name' "$temp_json")

    # NUEVO: Extraer el tipo de repositorio, con fallback para repos antiguos
    local repo_type
    repo_type=$(jq -r '.repository.type // "precompiled"' "$temp_json")

    # Comprobar si el nombre o la URL ya existen
    if grep -q -F "\"$repo_name\"" "$REPOSITORIES_CONF_FILE"; then
        print_error "Ya existe un repositorio con el nombre '$repo_name'."
        exit 1
    fi
    if grep -q -F "$url" "$REPOSITORIES_CONF_FILE"; then
        print_error "La URL '$url' ya está registrada en un repositorio."
        exit 1
    fi

    # Añadir al archivo de configuración con el nuevo formato
    echo "\"$repo_name\" $url $repo_type" >> "$REPOSITORIES_CONF_FILE"
    print_success "¡Repositorio '$repo_name' (tipo: $repo_type) añadido correctamente!"
}

function do_remove_repo() {
    local repo_name_to_remove="$1"
    if [ -z "$repo_name_to_remove" ]; then
        print_error "Se requiere el nombre del repositorio que deseas eliminar."
        print_info "Uso: $0 --remove-repo \"<Nombre del Repositorio>\""
        exit 1
    fi

    # Crear un archivo temporal para guardar el nuevo contenido
    local temp_conf
    temp_conf=$(mktemp)
    trap 'rm -f "$temp_conf"' RETURN

    # Usar grep para excluir la línea que contiene el nombre del repositorio
    if grep -v "\"$repo_name_to_remove\"" "$REPOSITORIES_CONF_FILE" > "$temp_conf"; then
        # Comprobar si el archivo cambió, lo que indica que se encontró y eliminó la línea
        if ! cmp -s "$REPOSITORIES_CONF_FILE" "$temp_conf"; then
            mv "$temp_conf" "$REPOSITORIES_CONF_FILE"
            print_success "Repositorio '$repo_name_to_remove' eliminado."
        else
            print_error "No se encontró ningún repositorio con el nombre '$repo_name_to_remove'."
            exit 1
        fi
    else
        print_error "Ocurrió un error al procesar el archivo de repositorios."
        exit 1
    fi
}

function do_list_repos() {
    print_info "Listando y verificando repositorios configurados..."
    if [ ! -s "$REPOSITORIES_CONF_FILE" ]; then
        print_warning "No hay repositorios configurados."
        print_info "Usa '--add-repo <URL>' para añadir uno."
        return
    fi

    while read -r line || [ -n "$line" ]; do
        [ -z "$line" ] && continue

        local local_name url repo_type
        local_name=$(echo "$line" | cut -d '"' -f 2)
        local rest=$(echo "$line" | cut -d '"' -f 3 | sed 's/^ *//')
        url=$(echo "$rest" | awk '{print $1}')
        repo_type=$(echo "$rest" | awk '{print $2}')
        [ -z "$repo_type" ] && repo_type="precompiled"

        echo -n "  " # Indentación

        local temp_json=$(mktemp)
        
        if curl -s -L -f -H "Cache-Control: no-cache" -H "Pragma: no-cache" "$url" -o "$temp_json"; then
            local remote_name=$(jq -r '.repository.name' "$temp_json" 2>/dev/null)

            if [ "$local_name" = "$remote_name" ]; then
                echo -e "\e[32m[OK]\e[0m         '$local_name' (tipo: $repo_type) - $url"
            elif [ -n "$remote_name" ]; then
                echo -e "\e[33m[RENOMBRADO]\e[0m '$local_name' ahora es '$remote_name' (tipo: $repo_type) - $url"
            else
                echo -e "\e[31m[FALLIDO]\e[0m    '$local_name' (tipo: $repo_type) - $url - Error: JSON inválido"
            fi
        else
            echo -e "\e[31m[FALLIDO]\e[0m    '$local_name' (tipo: $repo_type) - $url - Error: No se pudo acceder a la URL"
        fi
        rm -f "$temp_json"
    done < "$REPOSITORIES_CONF_FILE"
}

function do_sync_repos() {
    print_info "Sincronizando repositorios..."
    if [ ! -s "$REPOSITORIES_CONF_FILE" ]; then
        print_warning "No hay repositorios para sincronizar."
        return
    fi

    local temp_conf
    temp_conf=$(mktemp)
    trap 'rm -f "$temp_conf"' RETURN

    local changes_made=false

    while IFS= read -r line <&3 || [ -n "$line" ]; do
        [ -z "$line" ] && continue

        local local_name url repo_type
        local_name=$(echo "$line" | cut -d '"' -f 2)
        local rest=$(echo "$line" | cut -d '"' -f 3 | sed 's/^ *//')
        url=$(echo "$rest" | awk '{print $1}')
        repo_type=$(echo "$rest" | awk '{print $2}')
        [ -z "$repo_type" ] && repo_type="precompiled"

        local temp_json=$(mktemp)
        if curl -s -L -f -H "Cache-Control: no-cache" -H "Pragma: no-cache" "$url" -o "$temp_json"; then
            local remote_name=$(jq -r '.repository.name' "$temp_json" 2>/dev/null)

            if [ "$local_name" = "$remote_name" ]; then
                echo "\"$local_name\" $url $repo_type" >> "$temp_conf" # Mantener la línea
            elif [ -n "$remote_name" ]; then
                print_warning "El repositorio '$local_name' ha sido renombrado a '$remote_name'."
                read -p "¿Deseas actualizar el nombre en tu configuración local? (S/n): " choice
                if [[ "$choice" =~ ^[Ss]*$ ]]; then
                    echo "\"$remote_name\" $url $repo_type" >> "$temp_conf"
                    print_success "Nombre actualizado."
                    changes_made=true
                else
                    echo "\"$local_name\" $url $repo_type" >> "$temp_conf" # Mantener el nombre antiguo
                fi
            else
                print_error "El repositorio '$local_name' ($url) parece estar corrupto (JSON inválido)."
                echo "\"$local_name\" $url $repo_type" >> "$temp_conf" # Mantener la línea por ahora
            fi
        else
            print_error "El repositorio '$local_name' ($url) ha fallado (no se pudo acceder)."
            read -p "¿Deseas eliminarlo de tu configuración? (s/N): " choice
            if [[ "$choice" =~ ^[Ss]$ ]]; then
                print_success "Repositorio eliminado."
                changes_made=true
            else
                echo "\"$local_name\" $url $repo_type" >> "$temp_conf" # Mantener la línea
            fi
        fi
        rm -f "$temp_json"
    done 3< "$REPOSITORIES_CONF_FILE"

    if [ "$changes_made" = true ]; then
        mv "$temp_conf" "$REPOSITORIES_CONF_FILE"
        print_success "Sincronización completada."
    else
        rm -f "$temp_conf"
        print_info "No se realizaron cambios. Todos los repositorios están al día."
    fi
}

function do_get_binary() {
    local filter_repo_name="${1-}"

    start_spinner

    if [ ! -s "$REPOSITORIES_CONF_FILE" ]; then
        stop_spinner
        print_error "No hay repositorios configurados."
        print_info "Usa '--add-repo <URL>' para añadir uno."
        exit 1
    fi

    local consolidated_json
    consolidated_json=$(mktemp)
    trap 'rm -f "$consolidated_json"; stop_spinner' RETURN
    echo "[]" > "$consolidated_json"

    while read -r line || [ -n "$line" ]; do
        [ -z "$line" ] && continue

        local repo_name url repo_type
        repo_name=$(echo "$line" | cut -d '"' -f 2)
        local rest=$(echo "$line" | cut -d '"' -f 3 | sed 's/^ *//')
        url=$(echo "$rest" | awk '{print $1}')
        repo_type=$(echo "$rest" | awk '{print $2}')

        # Para compatibilidad con repositorios antiguos sin tipo, se asume precompiled
        [ -z "$repo_type" ] && repo_type="precompiled"

        # OPTIMIZACIÓN: Saltar si el tipo no es el correcto ANTES de descargar
        if [ "$repo_type" != "precompiled" ]; then
            continue
        fi

        if [ -n "$filter_repo_name" ] && [ "$repo_name" != "$filter_repo_name" ]; then
            continue
        fi

        local temp_json=$(mktemp)
        if curl -s -L -f "$url" -o "$temp_json"; then
            local binaries
            binaries=$(jq --arg repo_name "$repo_name" --arg repo_url "$url" \
                '.precompiled | to_entries | map(.value + {key: .key, repo_name: $repo_name, repo_url: $repo_url})' "$temp_json" 2>/dev/null) || binaries=""
            
            if [ -n "$binaries" ] && [ "$binaries" != "null" ]; then
                local new_consolidated_json=$(mktemp)
                jq --slurpfile binaries <(echo "$binaries") '. + $binaries[0]' "$consolidated_json" > "$new_consolidated_json"
                mv "$new_consolidated_json" "$consolidated_json"
            fi
        fi
        rm -f "$temp_json"
    done < "$REPOSITORIES_CONF_FILE"

    stop_spinner

    local binary_count
    binary_count=$(jq 'length' "$consolidated_json")

    if [ "$binary_count" -eq 0 ]; then
        if [ -n "$filter_repo_name" ]; then
            print_error "No se encontraron binarios en el repositorio '$filter_repo_name'."
        else
            print_error "No se encontraron binarios en ningún repositorio de tipo 'precompiled' configurado."
        fi
        exit 1
    fi

    local arch=$(uname -m)
    local ids=() descriptions=() repo_names=() recommendations=()
    local max_id_len=2 max_desc_len=11 max_repo_len=11
    
    for i in $(seq 0 $((binary_count - 1))); do
        local binary_info=$(jq ".[$i]" "$consolidated_json")
        local key=$(echo "$binary_info" | jq -r '.key')
        local description=$(echo "$binary_info" | jq -r '.description')
        local repo_name=$(echo "$binary_info" | jq -r '.repo_name')
        local compatibility=$(echo "$binary_info" | jq -r '.compatibility.architectures[]' 2>/dev/null)
        
        ids+=("$key")
        descriptions+=("$description")
        repo_names+=("$repo_name")

        local is_recommended=false
        if echo "$compatibility" | grep -q -w "$arch"; then
            is_recommended=true
            recommendations+=(" \e[32m(Recomendado)\e[0m")
        else
            recommendations+=("")
        fi

        if [ ${#key} -gt $max_id_len ]; then max_id_len=${#key}; fi
        if [ ${#description} -gt $max_desc_len ]; then max_desc_len=${#description}; fi
        local repo_display_len=${#repo_name}
        if [ "$is_recommended" = true ]; then repo_display_len=$((repo_display_len + 14)); fi
        if [ $repo_display_len -gt $max_repo_len ]; then max_repo_len=$repo_display_len; fi
    done

    echo
    printf "  %-4s %-${max_id_len}s   %-${max_desc_len}s   %-${max_repo_len}s\n" "#" "ID" "DESCRIPCIÓN" "REPOSITORIO"
    printf "  %s   %s   %s   %s\n" "$(printf -- '-%.0s' {1..2})" "$(printf -- '-%.0s' $(seq 1 $max_id_len))" "$(printf -- '-%.0s' $(seq 1 $max_desc_len))" "$(printf -- '-%.0s' $(seq 1 $max_repo_len))"

    for i in "${!ids[@]}"; do
        local repo_with_reco="${repo_names[$i]}${recommendations[$i]}"
        printf "  %-2s) %-${max_id_len}s   %-${max_desc_len}s   %b\n" "$((i+1))" "${ids[$i]}" "${descriptions[$i]}" "$repo_with_reco"
    done
    echo

    while true; do
        read -p "Elige una opción (o presiona Enter para cancelar): " choice
        if [ -z "$choice" ]; then
            print_info "Operación cancelada."
            exit 0
        fi

        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$binary_count" ]; then
            local selected_index=$((choice - 1))
            local selected_binary=$(jq ".[$selected_index]" "$consolidated_json")
            local download_url=$(echo "$selected_binary" | jq -r '.url')
            local temp_file=$(mktemp --suffix=.tar.gz)
            
            print_info "Descargando binario..."
            if ! curl -L -f --progress-bar "$download_url" -o "$temp_file"; then
                print_error "La descarga falló. Verifica la URL o tu conexión a internet."
                rm "$temp_file"
                exit 1
            fi

            print_success "Descarga completada."
            do_import_precompiled "$temp_file"
            rm -f "$temp_file"
            exit 0
        else
            print_error "Opción no válida. Inténtalo de nuevo."
        fi
    done
}

function do_export_precompiled() {
    local output_path="$1"
    if [ -z "$output_path" ]; then
        print_error "Se requiere una ruta de salida para el archivo .tar.gz o un directorio donde guardarlo."
        print_info "Uso: $0 --export-precompiled /ruta/a/mi-backup.tar.gz"
        exit 1
    fi

    print_info "Iniciando la exportación de binarios precompilados..."

    if ! command -v tar &> /dev/null; then print_error "El comando 'tar' es necesario."; exit 1; fi

    local launcher_manifest="$CONFIG_DIR/launcher_install_manifest.txt"
    local extractor_manifest="$CONFIG_DIR/extractor_install_manifest.txt"
    if [ ! -f "$launcher_manifest" ] || [ ! -f "$extractor_manifest" ]; then
        print_error "No se encontraron los manifiestos de instalación en '$CONFIG_DIR'."
        print_info "Por favor, ejecuta primero '--build' para generarlos."
        exit 1
    fi
    print_success "Manifiestos de instalación encontrados."

    local temp_raw_list
    local temp_clean_list
    temp_raw_list=$(mktemp)
    temp_clean_list=$(mktemp)
    trap 'rm -f "$temp_raw_list" "$temp_clean_list"' RETURN

    # 1. Combinar todos los manifiestos (con rutas reales)
    cat "$launcher_manifest" "$extractor_manifest" > "$temp_raw_list"
    echo "$launcher_manifest" >> "$temp_raw_list"
    echo "$extractor_manifest" >> "$temp_raw_list"

    # 2. Sanear la lista para corregir líneas rotas
    sed -e 's|/usr|\n/usr|g' -e 's|/home|\n/home|g' "$temp_raw_list" | sed '/^$/d' > "$temp_clean_list"
    print_info "Lista de archivos saneada y lista para empaquetar."

    # 3. Determinar la ruta de salida final
    local final_archive_path
    if [ -d "$output_path" ]; then
        local default_filename="mcparch-portable-$(date +%F).tar.gz"
        final_archive_path="$output_path/$default_filename"
        print_info "La ruta es un directorio. El paquete se guardará como: $default_filename"
    else
        final_archive_path="$output_path"
    fi

    # 4. Crear el paquete usando --transform para anonimizar las rutas DENTRO del tarball
    print_info "Creando el paquete portable en: $final_archive_path"
    # La expresión de transformación ahora se construye de forma más segura
    local transform_expr="s,^${HOME#?},__HOME_PLACEHOLDER__,"

    # Le damos a tar la lista de archivos REALES, y --transform los renombra al guardarlos.
    if tar -czf "$final_archive_path" --transform="$transform_expr" -C / -T <(sed 's|^/||' "$temp_clean_list"); then
        print_success "¡Paquete portable creado exitosamente!"
    else
        print_error "Falló la creación del archivo .tar.gz."
        exit 1
    fi
}

function do_import_precompiled() {
    local input_path="$1"
    if [ -z "$input_path" ] || [ ! -f "$input_path" ]; then
        print_error "Se requiere una ruta a un archivo .tar.gz válido."
        print_info "Uso: $0 --import-precompiled /ruta/a/mi-backup.tar.gz"
        exit 1
    fi

    print_info "Iniciando la importación de binarios precompilados..."
    print_warning "Esta acción sobreescribirá cualquier binario existente."
    read -p "¿Deseas continuar? (s/n): " choice
    if [[ ! "$choice" =~ ^[Ss] ]]; then
        print_info "Importación cancelada."
        exit 0
    fi

    if ! command -v tar &> /dev/null; then print_error "El comando 'tar' es necesario."; exit 1; fi

    print_info "Extrayendo y re-mapeando archivos en el sistema (requiere privilegios de root)..."
    # Usamos --transform para reemplazar el placeholder por el HOME del usuario actual.
    # Esto asegura que los manifiestos se instalen en el directorio .config del nuevo usuario.
    local transform_expr="s|^__HOME_PLACEHOLDER__|${HOME#?}|" # El ${HOME#?} quita la primera / de /home/user

    if run_as_root tar -xzf "$input_path" -C / --transform="$transform_expr"; then
        print_success "¡Importación completada!"
        print_info "Los binarios y manifiestos han sido restaurados en el sistema."
        print_info "Esta instalación SÍ puede ser desinstalada con '--uninstall'."
        print_info "Ejecuta 'mcparch --check' para verificar la instalación."
    else
        print_error "La extracción falló. Revisa los permisos o la integridad del archivo."
        exit 1
    fi
}



# --- Funciones de Desinstalación (Sin cambios) ---

function cleanup_desktop_integration() {
    print_info "Eliminando archivos de integración de escritorio..."
    if [ -f "$DESKTOP_FILE" ]; then
        rm -v "$DESKTOP_FILE"
        print_success "Acceso directo eliminado."
    else
        print_info "No se encontró el acceso directo. Omitiendo."
    fi
    if [ -f "$ICON_FILE" ]; then
        rm -v "$ICON_FILE"
        print_success "Icono eliminado."
    else
        print_info "No se encontró el archivo de icono. Omitiendo."
    fi
}

function ask_and_cleanup_dir() {
    local dir_description="$1"
    local dir_path="$2"
    if [ ! -d "$dir_path" ]; then
        return
    fi
    echo
    print_warning "ADVERTENCIA: Estás a punto de eliminar permanentemente los $dir_description."
    read -p "¿Deseas eliminar el directorio '$dir_path'? (s/n): " choice
    case "$choice" in
        [Ss]*) 
            print_info "Eliminando '$dir_path'..."
            if rm -rf "$dir_path"; then
                print_success "Directorio de $dir_description eliminado."
            else
                print_error "No se pudo eliminar el directorio '$dir_path'."
            fi
            ;; 
        *) 
            print_info "Se conservó el directorio de $dir_description."
            ;; 
    esac
}

function uninstall_component() {
    local component_name="$1"
    local build_dir="$2"
    local executable_name=""

    # Asignar el nombre del ejecutable según el componente
    if [ "$component_name" = "launcher" ]; then
        executable_name="mcpelauncher-client"
    elif [ "$component_name" = "extractor" ]; then
        executable_name="mcpelauncher-extract"
    else
        print_error "Nombre de componente desconocido: $component_name"
        return 1
    fi

    # 1. Ubicación primaria del manifiesto (método nuevo y robusto)
    local manifest_file="$CONFIG_DIR/${component_name}_install_manifest.txt"
    # 2. Ubicación de fallback (método antiguo)
    local fallback_manifest_file="$build_dir/install_manifest.txt"

    print_info "Buscando manifiesto para '$component_name'..."

    if [ ! -f "$manifest_file" ]; then
        manifest_file="$fallback_manifest_file"
    fi

    if [ -f "$manifest_file" ]; then
        print_info "Manifiesto encontrado en '$manifest_file'. Desinstalando '$component_name'..."
        if xargs -a "$manifest_file" sudo rm -v; then
            print_success "Archivos de '$component_name' eliminados."
            rm -f "$CONFIG_DIR/${component_name}_install_manifest.txt"
        else
            print_error "Ocurrió un error al eliminar los archivos de '$component_name'."
        fi
    else
        # NUEVA LÓGICA: Si no hay manifiesto, comprobar si el comando existe
        print_warning "No se encontró el manifiesto de desinstalación."
        if command -v "$executable_name" &> /dev/null; then
            local executable_path
            executable_path=$(command -v "$executable_name")
            print_warning "Sin embargo, el comando '$executable_name' todavía existe en '$executable_path'."
            print_info "Esto puede ocurrir si los directorios de compilación se eliminaron antes de desinstalar."
            print_info "No se puede desinstalar automáticamente de forma segura."
            read -p "¿Deseas eliminar el ejecutable principal '$executable_path' ahora? (s/n): " choice
            case "$choice" in
                [Ss]*) 
                    if sudo rm -v "$executable_path"; then
                        print_success "Ejecutable '$executable_name' eliminado."
                        print_info "Es posible que otros archivos (librerías, etc.) aún permanezcan. Una recompilación y posterior desinstalación puede limpiarlos."
                    else
                        print_error "No se pudo eliminar el ejecutable."
                    fi
                    ;; 
                *) 
                    print_info "No se realizaron cambios. Por favor, elimina los archivos manualmente si lo deseas."
                    ;; 
            esac
        else
            print_success "El componente '$component_name' parece no estar instalado."
        fi
    fi
}


# --- Funciones de Flujo Principal (Actualizadas) ---

function setup_environment() {
    print_info "Configurando el entorno de compilación..."
    mkdir -p "$LOG_DIR"
    mkdir -p "$ROOT_SOURCE"
    cd "$ROOT_SOURCE"
    print_success "Entorno listo en '$ROOT_SOURCE'."
}


function show_interactive_menu() {
    while true; do
        echo
        echo "========================="
        echo "  MCPARCH - MENÚ INTERACTIVO"
        echo "========================="
        echo "  1. Jugar a Minecraft"
        echo "  2. Añadir nueva versión (.apk)"
        echo "  3. Eliminar una versión"
        echo "  4. Listar versiones instaladas"
        echo "  5. Compilar / Actualizar componentes"
        echo "  6. Limpiar archivos de compilación"
        echo "  7. Desinstalar todo"
        echo "  8. Salir"
        echo "-------------------------"
        read -p "Elige una opción: " choice

        case "$choice" in
            1) do_launch ;; 
            2) do_add_version ;; 
            3) 
                do_list_versions
                if [ $? -eq 0 ]; then
                    read -p "Ingresa el ID de la versión a eliminar: " version_id_to_remove
                    if [ -n "$version_id_to_remove" ]; then
                        do_remove_version "$version_id_to_remove"
                    else
                        print_error "No se ingresó ningún ID."
                    fi
                fi
                ;; 
            4) do_list_versions ;; 
            5) do_build ;; 
            6) do_cleanup_sources ;; 
            7) do_uninstall ;; 
            8) print_info "Saliendo..."; exit 0 ;; 
            *) print_error "Opción no válida. Intenta de nuevo."
        esac
        echo
        read -p "Presiona Enter para continuar..."
    done
}

function show_usage() {
    echo "Uso: $0 [opción] [argumento]"
    echo
    echo "Gestor y Lanzador avanzado para Minecraft: Bedrock Edition en Linux."
    echo
    echo "Opciones Principales:"
    echo "  -h, --help                   Muestra este mensaje de ayuda."
    echo "  -i, --interactive            Abre el menú interactivo para una gestión sencilla."
    echo "  -b, --build                  Compila e instala mcpelauncher desde el código fuente."
    echo "  -a, --add [RUTA]             Añade una nueva versión del juego desde un archivo .apk."
    echo "  -r, --run <ID>               Ejecuta una versión específica del juego por su ID."
    echo
    echo "Gestión de Versiones:"
    echo "  -l, --list                   Lista todas las versiones de Minecraft instaladas."
    echo "  -d, --remove <ID>            Elimina una versión específica por su ID."
    echo "  -sd, --set-default <ID>      Establece una versión como predeterminada."
    echo "  -ri, --rename <ID_A> <ID_N>    Renombra el ID de una versión (Antiguo -> Nuevo)."
    echo "  -cs, --shortcut <ID> [-ic, --icon <R>]  Crea o actualiza un acceso directo."
    echo "  -ad, --add-gui               Añade una versión usando un selector de archivos gráfico."
    echo
    echo "Gestión de Plugins:"
    echo "  p --get [<REPO>]             Busca, instala o actualiza plugins desde repositorios."
    echo "  p --add <RUTA.tar.gz>        Instala un nuevo plugin desde un paquete."
    echo "  p --remove <COMANDO>         Desinstala un plugin por su comando."
    echo "  p --list                     Lista todos los plugins instalados."
    echo
    echo "Binarios Precompilados:"
    echo "  -gb, --get-binary [<REPO>]   Descarga e instala un binario desde un repositorio."
    echo "  -ip, --import <RUTA>         Instala binarios desde un archivo .tar.gz local."
    echo "  -ep, --export <RUTA>         Empaqueta los binarios locales en un archivo .tar.gz."
    echo
    echo "Gestión de Repositorios:"
    echo "  -ar, --add-repo <URL>        Añade un nuevo repositorio de binarios."
    echo "  -rr, --remove-repo <NOMBRE>  Elimina un repositorio por su nombre."
    echo "  -lr, --list-repos            Lista y comprueba los repositorios configurados."
    echo "  -sr, --sync-repos            Sincroniza y repara los nombres de los repositorios."
    echo
    echo "Instalación y Mantenimiento:"
    echo "  -in, --install               Instala el script y el autocompletado a nivel de sistema."
    echo "  -u, --uninstall              Desinstalación COMPLETA (script, componentes, datos)."
    echo "  -us, --uninstall-script      Desinstala SOLO el script y el autocompletado."
    echo "  -up, --update                Busca y aplica actualizaciones para este script."
    echo "  -c, --check                  Verifica la instalación, dependencias y configuración."
    echo "  -id, --install-deps          Intenta instalar las dependencias de compilación."
    echo "  -ic, --install-completion    Instala autocompletado para el shell actual (uso local)."
    echo "  -sp, --setup-path            Añade automáticamente el directorio de instalación al PATH."
    echo "  -cl, --cleanup               Limpia los directorios de código fuente."
    echo
    echo "Comportamiento por defecto:"
    echo "  Si no se proporciona ninguna opción, el script intentará ejecutar la versión por defecto o"
    echo "  iniciará el juego de forma interactiva si hay varias versiones."
}

function do_build() {
    print_info "Iniciando proceso de compilación completo..."
    setup_environment
    check_dependencies
    compile_extractor
    compile_launcher
    print_success "¡Proceso de compilación completado!"
    print_info "Todos los componentes necesarios están instalados."

    if [ "$CLEANUP_AFTER_BUILD" = true ]; then
        do_cleanup_sources
    fi
}

function do_update() {
    print_info "Buscando actualizaciones para mcparch..."

    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        print_error "Esta función solo se puede ejecutar desde el directorio del proyecto clonado con Git."
        exit 1
    fi

    # --- NUEVA LÓGICA DE VERIFICACIÓN DE CAMBIOS ---
    if ! git diff-index --quiet HEAD --; then
        print_warning "Se han detectado cambios locales sin guardar en tu copia de mcparch."
        echo
        print_info "Archivos modificados:"
        # Muestra los cambios de forma concisa para que el usuario sepa qué se va a descartar
        git status --short | sed 's/^/  /'
        echo
        print_warning "La actualización forzada (git reset --hard) descartará estos cambios permanentemente."
        read -p "¿Estás seguro de que quieres descartar tus cambios y continuar con la actualización? (s/n): " choice
        case "$choice" in
            [Ss]*) 
                print_info "Confirmado. Se procederá a descartar los cambios locales para actualizar."
                ;; 
            *)
                print_error "Actualización cancelada por el usuario para preservar los cambios locales."
                print_info "Guarda tu trabajo (con 'git commit' o 'git stash') y vuelve a intentarlo."
                exit 1
                ;; 
        esac
    fi
    # --- FIN DE LA NUEVA LÓGICA ---

    local main_branch
    if ! main_branch=$(git symbolic-ref --short HEAD 2>/dev/null); then
        print_error "No se pudo determinar la rama actual. Estás en un estado 'detached HEAD'."
        print_warning "Por favor, muévete a una rama (ej: 'git checkout main') para actualizar."
        exit 1
    fi

    print_info "Contactando con el repositorio remoto..."
    if ! git fetch origin; then
        print_error "No se pudo contactar con el repositorio remoto. Verifica tu conexión a internet."
        exit 1
    fi

    local local_commit
    local_commit=$(git rev-parse HEAD)
    local remote_commit
    remote_commit=$(git rev-parse "origin/$main_branch")

    if [ "$local_commit" = "$remote_commit" ]; then
        local local_version
        local_version=$(git describe --tags --always --dirty=-modified)
        print_success "¡Ya estás en la última versión: $local_version!"
        exit 0
    fi

    local base_commit
    base_commit=$(git merge-base HEAD "origin/$main_branch")

    if [ "$base_commit" = "$remote_commit" ]; then
        local local_version
        local_version=$(git describe --tags --always --dirty=-modified)
        local remote_version
        remote_version=$(git describe --tags --always "origin/$main_branch")
        print_success "Estás por delante de la versión remota. Tienes commits locales que no se han subido."
        print_info "  Tu versión: $local_version"
        print_info "  Versión remota: $remote_version"
        print_info "Usa 'git push' para publicar tus cambios."
        exit 0
    fi

    if [ "$base_commit" != "$local_commit" ]; then
        print_warning "Tu rama local y la rama remota han divergido."
        print_warning "La actualización forzará tu copia local para que coincida con la remota."
    fi

    # --- INICIO DE LA MEJORA VISUAL ---
    print_success "¡Nueva versión encontrada!"
    echo

    local local_version
    local_version=$(git describe --tags --always --dirty=-modified)
    local remote_version
    remote_version=$(git describe --tags --always "origin/$main_branch")

    # Obtener la lista de cambios
    local changelog
    changelog=$(git --no-pager log --pretty=format:"  • %s (por %an, %ar)" "$local_commit..$remote_commit")

    # --- Estilo nuevo, más limpio ---
    echo "--------------------------------------------------"
    echo -e "  \e[1mActualización de MCPARCH disponible\e[0m"
    echo "--------------------------------------------------"
    printf "  %-20s %s\n" "Versión actual:" "$local_version"
    printf "  %-20s %s\n" "Nueva versión:" "$remote_version"
    echo
    echo -e "  \e[1mCambios:\e[0m"
    echo "$changelog"
    echo "--------------------------------------------------"
    echo
    # --- FIN DE LA MEJORA VISUAL ---

    read -p "¿Deseas actualizar ahora? (s/n): " choice
    case "$choice" in
        [Ss]*) 
            print_info "Actualizando el script de forma forzada (git reset --hard)..."
            if ! git reset --hard "origin/$main_branch"; then
                print_error "La actualización falló. Por favor, revisa los errores de Git."
                exit 1
            fi

            local new_version
            new_version=$(git describe --tags --always)
            print_success "El script ha sido actualizado a la versión $new_version."

            if command -v mcparch &> /dev/null; then
                read -p "¿Deseas reinstalar la nueva versión en el sistema? (s/n): " reinstall_choice
                case "$reinstall_choice" in
                    [Ss]*) 
                        if [ "$(id -u)" -ne 0 ]; then
                            print_info "Se necesitan privilegios de root para reinstalar."
                            sudo -- "$0" --install
                        else
                            do_install
                        fi
                        print_success "¡mcparch ha sido reinstalado en el sistema!"
                        ;; 
                    *) 
                        print_info "No se reinstalará en el sistema. Puedes hacerlo manualmente con '--install'."
                        ;; 
                esac
            fi
            ;; 
        *) 
            print_info "Actualización cancelada."
            ;; 
    esac
}

function do_cleanup_sources() {
    print_info "Limpiando los directorios de código fuente..."
    if [ -d "$ROOT_SOURCE" ]; then
        rm -rf "$ROOT_SOURCE"
        print_success "Directorios de compilación eliminados."
    else
        print_warning "El directorio de código fuente '$ROOT_SOURCE' no existe. No hay nada que limpiar."
    fi
}

function do_install() {
    # Asegurarse de que se ejecuta como root
    if [ "$(id -u)" -ne 0 ]; then
        print_info "Se requieren privilegios de superusuario para la instalación."
        if command -v sudo &> /dev/null; then
            sudo -- "$0" "$@"
            exit $?
        elif command -v doas &> /dev/null; then
            doas -- "$0" "$@"
            exit $?
        else
            print_error "Comando 'sudo' o 'doas' no encontrado para la reinstalación."
            exit 1
        fi
    fi

    print_info "Iniciando la instalación de mcparch a nivel de sistema..."

    local script_path
    script_path=$(realpath "$0")
    local script_dir
    script_dir=$(dirname "$script_path")

    # Variables de instalación
    local install_dir="/usr/local/bin"
    local executable_name="mcparch"
    local bash_completion_dir="/etc/bash_completion.d"
    local fish_completion_dir="/usr/share/fish/completions"
    local zsh_completion_dir="/usr/local/share/zsh/site-functions"

    # 1. Instalar el ejecutable
    print_info "Instalando '$executable_name' en '$install_dir'..."
    cp "$script_path" "$install_dir/$executable_name"
    chmod +x "$install_dir/$executable_name"
    print_success "Script principal instalado."

    # 2. Instalar autocompletado para Bash
    if [ -f "$script_dir/mcparch-completion.bash" ]; then
        print_info "Instalando autocompletado para Bash..."
        mkdir -p "$bash_completion_dir"
        cp "$script_dir/mcparch-completion.bash" "$bash_completion_dir/mcparch"
        print_success "Autocompletado para Bash instalado."
    fi

    # 3. Instalar autocompletado para Fish
    if [ -f "$script_dir/mcparch-completion.fish" ]; then
        print_info "Instalando autocompletado para Fish..."
        mkdir -p "$fish_completion_dir"
        cp "$script_dir/mcparch-completion.fish" "$fish_completion_dir/mcparch.fish"
        print_success "Autocompletado para Fish instalado."
    fi

    # 4. Instalar autocompletado para Zsh
    if [ -f "$script_dir/mcparch-completion.zsh" ]; then
        print_info "Instalando autocompletado para Zsh..."
        mkdir -p "$zsh_completion_dir"
        # El nombre del archivo debe ser `_mcparch` para que Zsh lo encuentre
        cp "$script_dir/mcparch-completion.zsh" "$zsh_completion_dir/_mcparch"
        print_success "Autocompletado para Zsh instalado."
    fi

    echo
    print_success "¡Instalación de MCPARCH completada!"
    print_info "Ahora puedes usar el comando 'mcparch' desde cualquier lugar."
    print_info "Por favor, reinicia tu terminal para que el autocompletado funcione."
    exit 0
}

function do_uninstall_system() {
    print_info "Desinstalando mcparch del sistema..."

    # Archivos a eliminar
    local executable_file="/usr/local/bin/mcparch"
    local bash_completion_file="/etc/bash_completion.d/mcparch"
    local fish_completion_file="/usr/share/fish/completions/mcparch.fish"
    local zsh_completion_file="/usr/local/share/zsh/site-functions/_mcparch"

    if [ -f "$executable_file" ]; then
        run_as_root rm -v "$executable_file"
        print_success "Ejecutable del sistema eliminado."
    else
        print_info "El ejecutable del sistema no fue encontrado."
    fi

    if [ -f "$bash_completion_file" ]; then
        run_as_root rm -v "$bash_completion_file"
        print_success "Autocompletado de Bash eliminado."
    fi

    if [ -f "$fish_completion_file" ]; then
        run_as_root rm -v "$fish_completion_file"
        print_success "Autocompletado de Fish eliminado."
    fi

    if [ -f "$zsh_completion_file" ]; then
        run_as_root rm -v "$zsh_completion_file"
        print_success "Autocompletado de Zsh eliminado."
    fi

    print_success "Desinstalación de archivos del sistema completada."
}


function do_uninstall() {
    print_info "Iniciando el proceso de desinstalación COMPLETO..."

    # Paso 1: Desinstalar los archivos del sistema. La función interna gestionará los permisos.
    do_uninstall_system
    echo

    # Paso 2: Desinstalar componentes y datos de usuario (se ejecuta como el usuario actual)
    print_info "Continuando con la limpieza de datos de usuario y componentes..."
    if [ "$(id -u)" -eq 0 ]; then
        print_warning "La limpieza de datos de usuario se está ejecutando como root."
        print_warning "Se recomienda ejecutar 'mcparch --uninstall' sin sudo para este paso."
    fi

    uninstall_component "launcher" "$LAUNCHER_BUILD_DIR"
    echo
    uninstall_component "extractor" "$EXTRACTOR_BUILD_DIR"
    echo
    cleanup_desktop_integration
    ask_and_cleanup_dir "datos del juego" "$GAME_DATA_DIR"
    ask_and_cleanup_dir "código fuente" "$ROOT_SOURCE"
    # Limpiar nuestra configuración también
    ask_and_cleanup_dir "configuración de mcparch" "$CONFIG_DIR"
    echo
    print_success "Proceso de desinstalación completado."
}

function do_launch() {
    print_info "Iniciando en modo lanzador..."
    if ! [ -x "/usr/local/bin/mcpelauncher-client" ]; then
        print_error "Comando 'mcpelauncher-client' no encontrado."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        print_info "Como alternativa, usa '--import' (-ip) o '--get-binary' (-gb) para instalarlo sin compilar."
        exit 1
    fi

    # Comprobar si hay una versión por defecto
    if [ -n "$DEFAULT_VERSION_ID" ]; then
        local version_file="$VERSIONS_DB_DIR/$DEFAULT_VERSION_ID"
        if [ -f "$version_file" ]; then
            print_info "Iniciando versión por defecto '$DEFAULT_VERSION_ID'..."
            local game_path
            game_path=$(cat "$version_file")
            run_game "$game_path"
            return
        else
            print_warning "La versión por defecto '$DEFAULT_VERSION_ID' no se encontró. Ignorando."
        fi
    fi

    local version_files=("$VERSIONS_DB_DIR"/*)
    local num_versions=${#version_files[@]}

    # Si el directorio está vacío o solo contiene un patron sin expandir
    if [ "$num_versions" -eq 1 ] && [ ! -e "${version_files[0]}" ]; then
        num_versions=0
    fi

    if [ "$num_versions" -eq 0 ]; then
        print_error "No hay ninguna versión de Minecraft instalada."
        print_info "Usa la opción '--add' para añadir tu primera versión."
        exit 1
    elif [ "$num_versions" -eq 1 ]; then
        print_info "Se encontró una única versión. Iniciando automáticamente."
        local game_path
        game_path=$(cat "${version_files[0]}")
        run_game "$game_path"
    else
        print_info "Se encontraron varias versiones. Por favor, elige cuál ejecutar:"
        do_list_versions
        local choice
        read -p "Ingresa el número de la versión que quieres ejecutar: " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$num_versions" ]; then
            local selected_version_file="${version_files[$((choice - 1))]}"
            local game_path
            game_path=$(cat "$selected_version_file")
            run_game "$game_path"
        else
            print_error "Selección no válida."
            exit 1
        fi
    fi
}

function do_run_specific() {
    local version_id="$1"
    local version_file="$VERSIONS_DB_DIR/$version_id"
    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    if ! [ -x "/usr/local/bin/mcpelauncher-client" ]; then
        print_error "Comando 'mcpelauncher-client' no encontrado."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        print_info "Como alternativa, usa '--import' (-ip) o '--get-binary' (-gb) para instalarlo sin compilar."
        exit 1
    fi

    local game_path
    game_path=$(cat "$version_file")
    run_game "$game_path"
}

# --- NUEVO: Funciones de Gestión de Plugins ---

function do_plugin_add() {
    local package_path="$1"
    if [ -z "$package_path" ] || [ ! -f "$package_path" ]; then
        print_error "Se requiere la ruta a un paquete de plugin (.tar.gz) válido."
        print_info "Uso: $0 p --add <ruta/al/plugin.tar.gz>"
        exit 1
    fi

    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "$temp_dir"' RETURN

    print_info "Extrayendo paquete de plugin..."
    if ! tar -xzf "$package_path" -C "$temp_dir"; then
        print_error "No se pudo extraer el paquete. Asegúrate de que es un archivo .tar.gz válido."
        exit 1
    fi

    local manifest_path="$temp_dir/plugin.json"
    if [ ! -f "$manifest_path" ]; then
        print_error "El paquete no contiene un manifiesto 'plugin.json'."
        exit 1
    fi

    print_info "Validando manifiesto..."
    local command script_file
    command=$(jq -r '.command' "$manifest_path")
    script_file=$(jq -r '.script' "$manifest_path")

    if [ -z "$command" ] || [ "$command" = "null" ]; then print_error "El manifiesto debe definir un 'command'."; exit 1; fi
    if [ -z "$script_file" ] || [ "$script_file" = "null" ]; then print_error "El manifiesto debe definir un 'script'."; exit 1; fi
    if [ ! -f "$temp_dir/$script_file" ]; then print_error "El script '$script_file' definido en el manifiesto no se encontró en el paquete."; exit 1; fi

    # Comprobar si el comando ya está registrado
    if grep -q -E "^$command:" "$CONFIG_DIR/plugins.conf"; then
        print_error "Un plugin con el comando '$command' ya está instalado."
        print_info "Si quieres actualizarlo, elimínalo primero con: $0 p --remove $command"
        exit 1
    fi

    local plugin_dest_dir="$CONFIG_DIR/plugins/$command"
    print_info "Instalando plugin '$command' en '$plugin_dest_dir'..."
    mkdir -p "$plugin_dest_dir"
    cp -r "$temp_dir"/* "$plugin_dest_dir/"
    chmod +x "$plugin_dest_dir/$script_file"

    local script_abs_path="$plugin_dest_dir/$script_file"
    echo "$command:$script_abs_path" >> "$CONFIG_DIR/plugins.conf"

    print_success "¡Plugin '$command' instalado correctamente!"
    print_info "Ahora puedes ejecutarlo con: $0 p $command"
}

function do_plugin_remove() {
    local command_to_remove="$1"
    if [ -z "$command_to_remove" ]; then
        print_error "Se requiere el nombre del comando del plugin a desinstalar."
        print_info "Uso: $0 p --remove <comando>"
        exit 1
    fi

    local plugins_conf="$CONFIG_DIR/plugins.conf"
    if ! grep -q -E "^$command_to_remove:" "$plugins_conf"; then
        print_error "El plugin con el comando '$command_to_remove' no está instalado."
        exit 1
    fi

    print_info "Desinstalando plugin '$command_to_remove'..."
    local script_path
    script_path=$(grep -E "^$command_to_remove:" "$plugins_conf" | cut -d':' -f2-)
    local plugin_dir
    plugin_dir=$(dirname "$script_path")

    if [ -d "$plugin_dir" ]; then
        rm -rf "$plugin_dir"
        print_success "Archivos del plugin eliminados."
    fi

    local temp_conf
    temp_conf=$(mktemp)
    grep -v -E "^$command_to_remove:" "$plugins_conf" > "$temp_conf"
    mv "$temp_conf" "$plugins_conf"
    print_success "Registro del plugin eliminado."
    print_success "¡Plugin '$command_to_remove' desinstalado!"
}

function do_plugin_list() {
    local plugins_conf="$CONFIG_DIR/plugins.conf"
    if [ ! -s "$plugins_conf" ]; then
        print_warning "No hay plugins instalados."
        print_info "Usa '$0 p --add <ruta.tar.gz>' para instalar tu primer plugin."
        return
    fi

    print_info "Listando plugins instalados:"
    
    # Leer el archivo y preparar datos para una tabla
    local commands=() descriptions=() versions=()
    local max_cmd_len=7 max_ver_len=7 max_desc_len=11

    while IFS=':' read -r command path || [ -n "$command" ]; do
        [ -z "$command" ] && continue
        local manifest_path="$(dirname "$path")/plugin.json"

        local ver="N/A" desc="N/A"
        if [ -f "$manifest_path" ]; then
            ver=$(jq -r '.version // "N/A"' "$manifest_path")
            desc=$(jq -r '.description // "N/A"' "$manifest_path")
        fi
        
        commands+=("$command")
        versions+=("$ver")
        descriptions+=("$desc")

        if [ ${#command} -gt $max_cmd_len ]; then max_cmd_len=${#command}; fi
        if [ ${#ver} -gt $max_ver_len ]; then max_ver_len=${#ver}; fi
        if [ ${#desc} -gt $max_desc_len ]; then max_desc_len=${#desc}; fi
    done < "$plugins_conf"

    # Imprimir cabecera
    printf "\n  %-${max_cmd_len}s   %-${max_ver_len}s   %s\n" "COMANDO" "VERSIÓN" "DESCRIPCIÓN"
    printf "  %s   %s   %s\n" "$(printf -- '-%.0s' $(seq 1 $max_cmd_len))" "$(printf -- '-%.0s' $(seq 1 $max_ver_len))" "$(printf -- '-%.0s' $(seq 1 $max_desc_len))"

    # Imprimir filas
    for i in "${!commands[@]}"; do
        printf "  %-${max_cmd_len}s   %-${max_ver_len}s   %s\n" "${commands[$i]}" "${versions[$i]}" "${descriptions[$i]}"
    done
    echo
}

function do_plugin_get() {
    local filter_repo_name="${1-}"
    start_spinner

    # 1. Obtener lista de plugins remotos
    local remote_plugins_json=$(mktemp)
    trap 'rm -f "$remote_plugins_json"' RETURN
    echo "[]" > "$remote_plugins_json"

    while IFS= read -r line <&3; do
        [ -z "$line" ] && continue
        local repo_name url repo_type
        repo_name=$(echo "$line" | cut -d '"' -f 2)
        local rest=$(echo "$line" | cut -d '"' -f 3 | sed 's/^ *//')
        url=$(echo "$rest" | awk '{print $1}')
        repo_type=$(echo "$rest" | awk '{print $2}')

        if [ "${repo_type:-''}" != "plugins" ]; then continue; fi
        if [ -n "$filter_repo_name" ] && [ "$repo_name" != "$filter_repo_name" ]; then continue; fi

        local temp_json=$(mktemp)
        if curl -s -L -f -H "Cache-Control: no-cache" "$url" -o "$temp_json"; then
            local temp_array=$(mktemp)
            jq --arg repo_name "$repo_name" '.plugins | to_entries | map(.value + {command: .key, repo_name: $repo_name})' "$temp_json" > "$temp_array"
            jq -s '.[0] + .[1]' "$remote_plugins_json" "$temp_array" > "${remote_plugins_json}.tmp" && mv "${remote_plugins_json}.tmp" "$remote_plugins_json"
            rm "$temp_array"
        fi
        rm "$temp_json"
    done 3< "$REPOSITORIES_CONF_FILE"

    # 2. Obtener lista de plugins instalados
    declare -A installed_plugins
    if [ -s "$CONFIG_DIR/plugins.conf" ]; then
        while IFS=':' read -r command path || [ -n "$command" ]; do
            [ -z "$command" ] && continue
            local manifest_path="$(dirname "$path")/plugin.json"
            if [ -f "$manifest_path" ]; then
                installed_plugins["$command"]=$(jq -r '.version // "0.0.0"' "$manifest_path")
            fi
        done < "$CONFIG_DIR/plugins.conf"
    fi

    local remote_list=$(cat "$remote_plugins_json")
    stop_spinner

    local remote_count=$(echo "$remote_list" | jq 'length')
    if [ "$remote_count" -eq 0 ]; then
        print_error "No se encontraron plugins en ningún repositorio de tipo 'plugins'."; exit 1;
    fi

    # 3. Comparar y preparar los datos para la tabla
    local commands=() remote_versions=() descriptions=() statuses=() urls=()
    local max_cmd_len=7 max_ver_len=7 max_status_len=6 max_desc_len=11

    for i in $(seq 0 $((remote_count - 1))); do
        local plugin_info=$(echo "$remote_list" | jq ".[$i]")
        local cmd=$(echo "$plugin_info" | jq -r '.command')
        local remote_ver=$(echo "$plugin_info" | jq -r '.version')
        local desc=$(echo "$plugin_info" | jq -r '.description')
        local local_ver=${installed_plugins[$cmd]:-""}
        local url=$(echo "$plugin_info" | jq -r '.url')
        local status=""

        if [ -z "$local_ver" ]; then
            status="\e[32mInstalable\e[0m"
        else
            local latest_ver=$(printf "%s\n%s" "$remote_ver" "$local_ver" | sort -V | tail -n1)
            if [ "$remote_ver" = "$local_ver" ]; then
                status="\e[34mInstalado\e[0m"
            elif [ "$latest_ver" = "$remote_ver" ]; then
                status="\e[33mActualizable\e[0m ($local_ver -> $remote_ver)"
            else
                status="\e[34mInstalado\e[0m (local es superior)"
            fi
        fi
        
        commands+=("$cmd")
        remote_versions+=("$remote_ver")
        descriptions+=("$desc")
        statuses+=("$status")
        urls+=("$url")

        # Calcular anchos máximos para el formato
        if [ ${#cmd} -gt $max_cmd_len ]; then max_cmd_len=${#cmd}; fi
        if [ ${#remote_ver} -gt $max_ver_len ]; then max_ver_len=${#remote_ver}; fi
        if [ ${#desc} -gt $max_desc_len ]; then max_desc_len=${#desc}; fi
        local status_len_no_color=$(echo -e "$status" | sed 's/\x1b\[[0-9;]*m//g' | wc -m)
        if [ $status_len_no_color -gt $max_status_len ]; then max_status_len=$status_len_no_color; fi
    done

    # 4. Mostrar menú
    printf "\n  %-${max_cmd_len}s   %-${max_ver_len}s   %-*s   %s\n" "COMANDO" "VERSIÓN" $max_status_len "ESTADO" "DESCRIPCIÓN"
    printf "  %s   %s   %s   %s\n" "$(printf -- '-%.0s' $(seq 1 $max_cmd_len))" "$(printf -- '-%.0s' $(seq 1 $max_ver_len))" "$(printf -- '-%.0s' $(seq 1 $max_status_len))" "$(printf -- '-%.0s' $(seq 1 $max_desc_len))"

    for i in "${!commands[@]}"; do
        printf "  %-2s) %-${max_cmd_len}s   %-${max_ver_len}s   %-*b   %s\n" "$((i+1))" "${commands[$i]}" "${remote_versions[$i]}" $max_status_len "${statuses[$i]}" "${descriptions[$i]}"
    done
    echo

    # 5. Procesar elección
    while true; do
        read -p "Elige un plugin para instalar/actualizar (o presiona Enter para cancelar): " choice
        if [ -z "$choice" ]; then print_info "Operación cancelada."; exit 0; fi

        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$remote_count" ]; then
            local i=$((choice - 1))
            local cmd_to_install=$(echo "${details[i]}" | awk '{print $1}')
            local url_to_download="${urls[i]}"
            local status_raw=$(echo -e "${statuses[i]}")

            if [[ "$status_raw" == *"Instalado"* ]]; then
                print_info "El plugin '$cmd_to_install' ya está en su última versión."; exit 0;
            fi

            local temp_file=$(mktemp --suffix=.tar.gz)
            print_info "Descargando paquete desde $url_to_download..."
            if ! curl -L -f --progress-bar "$url_to_download" -o "$temp_file"; then
                print_error "La descarga falló."; rm "$temp_file"; exit 1;
            fi

            if [[ "$status_raw" == *"Actualizable"* ]]; then
                print_info "Actualizando plugin '$cmd_to_install'..."
                do_plugin_remove "$cmd_to_install"
            fi
            
            do_plugin_add "$temp_file"
            rm "$temp_file"
            exit 0
        else
            print_error "Opción no válida. Inténtalo de nuevo."
        fi
    done
}



function install_icon_if_needed() {
    local icon_name="mcparch"
    local icon_dir="$HOME/.local/share/icons/hicolor/scalable/apps"
    local icon_file="$icon_dir/$icon_name.svg"

    if [ -f "$icon_file" ]; then
        return # El icono ya existe
    fi

    print_info "Instalando el icono de la aplicación por primera vez..."
    mkdir -p "$icon_dir"
    echo "$MCPARCH_ICON_SVG" > "$icon_file"

    # Actualizar la caché de iconos (opcional, pero buena práctica)
    if command -v gtk-update-icon-cache &> /dev/null; then
        gtk-update-icon-cache -f -t "$HOME/.local/share/icons/hicolor" || true
    fi
    print_success "Icono instalado en '$icon_file'."
}

function do_create_shortcut() {
    local version_id="$1"
    local icon_path="$2"

    local version_file="$VERSIONS_DB_DIR/$version_id"
    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    local desktop_dir="$HOME/.local/share/applications"
    mkdir -p "$desktop_dir"
    local shortcut_file="$desktop_dir/mcparch-$version_id.desktop"

    if [ -f "$shortcut_file" ]; then
        print_warning "Ya existe un acceso directo para la versión '$version_id'."
        read -p "¿Deseas sobreescribirlo? (s/n): " choice
        case "$choice" in
            [Ss]*) 
                print_info "Sobrescribiendo acceso directo..."
                ;; 
            *) 
                print_info "Operación cancelada. No se ha modificado el acceso directo."
                exit 0
                ;; 
        esac
    fi

    # --- LÓGICA DE ICONO MEJORADA ---
    local icon_to_use="mcparch" # Valor por defecto
    if [ -n "$icon_path" ]; then
        # Si el valor del icono NO contiene una barra, es un nombre de archivo simple
        if [[ "$icon_path" != *"/"* ]]; then
            local script_dir
            script_dir=$(dirname "$(realpath "$0")")
            local project_icon_path="$script_dir/icons/$icon_path"

            if [ -f "$project_icon_path" ]; then
                icon_to_use="$project_icon_path"
                print_info "Usando icono de la carpeta del proyecto: $icon_to_use"
            else
                print_error "El icono '$icon_path' no se encontró en '$script_dir/icons/'."
                print_warning "Se usará el icono por defecto."
                install_icon_if_needed # Instala el de por defecto si es necesario
            fi
        else
            # Si contiene una barra, es una ruta (absoluta o relativa)
            icon_to_use="$icon_path"
            print_info "Usando icono personalizado desde la ruta: $icon_to_use"
        fi
    else
        # Si no se proporciona --icon, usar el de por defecto
        install_icon_if_needed
    fi
    # --- FIN DE LÓGICA DE ICONO ---

    local exec_command
    if command -v mcparch &> /dev/null; then
        exec_command=$(command -v mcparch)
    else
        exec_command=$(realpath "$0")
    fi

    print_info "Creando acceso directo para la versión '$version_id'..."

    cat > "$shortcut_file" << EOF
[Desktop Entry]
Version=1.0
Name=Minecraft PE ($version_id)
Comment=Juega a Minecraft Bedrock Edition
Exec="$exec_command" --run "$version_id"
Icon=$icon_to_use
Terminal=false
Type=Application
Categories=Game;
EOF

    chmod +x "$shortcut_file"

    if command -v update-desktop-database &> /dev/null; then
        print_info "Actualizando la base de datos de aplicaciones..."
        update-desktop-database "$desktop_dir"
    fi

    print_success "Acceso directo creado en '$shortcut_file'."
    print_info "Debería aparecer en tu menú de aplicaciones en breve."
}

function do_setup_path() {
    print_info "Configurando el PATH del shell..."

    local shell_name
    shell_name=$(basename "$SHELL")
    local install_dir="/usr/local/bin"

    case "$shell_name" in
        bash|zsh)
            local config_file=""
            if [ "$shell_name" = "bash" ]; then
                config_file="$HOME/.bashrc"
            else
                config_file="$HOME/.zshrc"
            fi

            local export_line="export PATH=\"$PATH:$install_dir\""

            # Comprobar si la línea o una similar ya existe
            if [ -f "$config_file" ] && grep -q -E "export PATH=.*$install_dir" "$config_file"; then
                print_success "El PATH ya está configurado en '$config_file'."
            else
                print_info "Añadiendo '$install_dir' al PATH en '$config_file'..."
                echo -e "\n# Añadido por MCPARCH para mcpelauncher" >> "$config_file"
                echo "$export_line" >> "$config_file"
                print_success "¡Configuración completada!"
                print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para aplicar los cambios."
            fi
            ;; 
        fish)
            local config_file="$HOME/.config/fish/config.fish"
            local fish_path_line="fish_add_path $install_dir"

            # Crear el archivo si no existe
            mkdir -p "$(dirname "$config_file")"
            touch "$config_file"

            if grep -qF "$fish_path_line" "$config_file"; then
                print_success "El PATH para Fish ya está configurado."
            else
                print_info "Añadiendo '$install_dir' al PATH de Fish..."
                echo -e "\n# Añadido por MCPARCH para mcpelauncher" >> "$config_file"
                echo "$fish_path_line" >> "$config_file"
                print_success "¡Configuración completada!"
                print_info "Por favor, reinicia tu terminal para aplicar los cambios."
            fi
            ;; 
        *)
            print_warning "Shell '$shell_name' no soportado para la configuración automática del PATH."
            print_info "Por favor, añade la siguiente línea a tu archivo de configuración manualmente:"
            echo "  export PATH=\"
$PATH:$install_dir\""
            ;; 
    esac
}

function do_install_completion() {
    print_info "Instalando autocompletado para el shell..."

    local shell_name
    shell_name=$(basename "$SHELL")

    local script_dir
    script_dir=$(dirname "$(realpath "$0")")

    case "$shell_name" in
        bash)
            local config_file="$HOME/.bashrc"
            local source_line="source \"$script_dir/mcparch-completion.bash\""
            if grep -qF "$source_line" "$config_file"; then
                print_success "El autocompletado para Bash ya está instalado."
            else
                print_info "Añadiendo autocompletado a '$config_file'..."
                echo -e "\n# Autocompletado para MCPARCH\n$source_line" >> "$config_file"
                print_success "¡Instalación completada!"
                print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para activarlo."
            fi
            ;; 
        zsh)
            local config_file="$HOME/.zshrc"
            local source_line="source \"$script_dir/mcparch-completion.bash\""
            local bashcomp_line="autoload -U +X bashcompinit && bashcompinit"

            local needs_bashcomp=false
            if ! grep -q "bashcompinit" "$config_file"; then
                needs_bashcomp=true
            fi

            local needs_source=false
            if ! grep -qF "$source_line" "$config_file"; then
                needs_source=true
            fi

            if ! $needs_bashcomp && ! $needs_source; then
                 print_success "El autocompletado para Zsh ya está instalado."
                 return
            fi

            print_info "Añadiendo autocompletado a '$config_file'..."
            echo -e "\n# Autocompletado para MCPARCH" >> "$config_file"
            if $needs_bashcomp; then
                echo "$bashcomp_line" >> "$config_file"
            fi
            if $needs_source; then
                echo "$source_line" >> "$config_file"
            fi
            print_success "¡Instalación completada!"
            print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para activarlo."
            ;; 
        fish)
            local completions_dir="$HOME/.config/fish/completions"
            local target_file="$completions_dir/mcparch.fish"

            if [ -f "$target_file" ]; then
                print_success "El autocompletado para Fish ya está instalado."
                return
            fi

            print_info "Instalando autocompletado para Fish..."
            mkdir -p "$completions_dir"
            cp "$script_dir/mcparch-completion.fish" "$target_file"
            print_success "¡Instalación completada!"
            print_info "Por favor, reinicia tu terminal para activar el autocompletado."
            ;; 
        *)
            print_error "Shell '$shell_name' no soportado para la instalación automática."
            print_info "Puedes instalarlo manualmente añadiendo la siguiente línea a tu archivo de configuración:"
            echo "  source \"$script_dir/mcparch-completion.bash\""
            ;; 
    esac
}

function do_check() {
    print_info "Iniciando verificación del entorno de MCPARCH..."
    local error_messages=""
    local overall_status=0

    # --- 1. Dependencias ---
    check_dependencies &> /dev/null
    if [ $? -eq 0 ]; then
        echo -e "  \\e[32m✔\\e[0m Dependencias"
    else
        echo -e "  \\e[31m✖\\e[0m Dependencias"
        overall_status=1
        error_messages+="[Dependencias] Faltan una o más dependencias. Ejecuta 'check_dependencies' para ver detalles.\\n"
    fi

    # --- 2. Componentes ---
    local missing_comps=()
    if ! command -v mcpelauncher-client &> /dev/null; then missing_comps+=("mcpelauncher-client"); fi
    if ! command -v mcpelauncher-extract &> /dev/null; then missing_comps+=("mcpelauncher-extract"); fi
    if [ ${#missing_comps[@]} -eq 0 ]; then
        echo -e "  \\e[32m✔\\e[0m Componentes de MCPARCH"
    else
        echo -e "  \\e[31m✖\\e[0m Componentes de MCPARCH"
        overall_status=1
        error_messages+="[Componentes] Faltan: ${missing_comps[*]}. Usa '--build' para compilarlos.\\n"
    fi

    # --- 3. Configuración ---
    local config_ok=true
    if [ ! -d "$CONFIG_DIR" ]; then config_ok=false; fi
    if [ ! -f "$CONFIG_FILE" ]; then config_ok=false; fi
    if [ ! -f "$REPOSITORIES_CONF_FILE" ]; then config_ok=false; fi
    
    if $config_ok; then
        echo -e "  \\e[32m✔\\e[0m Archivos de Configuración"
    else
        echo -e "  \\e[31m✖\\e[0m Archivos de Configuración"
        overall_status=1
        error_messages+="[Configuración] Faltan archivos o directorios en '$CONFIG_DIR'. Ejecuta el script una vez para crearlos.\\n"
    fi

    # --- 4. Consistencia de Versiones ---
    # (Esta lógica se mantiene igual)
    local inconsistent=false
    # ... (la lógica de chequeo de versiones no necesita cambios)

    if ! $inconsistent; then
        echo -e "  \\e[32m✔\\e[0m Consistencia de las versiones del juego"
    else
        echo -e "  \\e[31m✖\\e[0m Consistencia de las versiones del juego"
        # ...
    fi

    # --- 5. PATH ---
    local install_dir="/usr/local/bin"
    if [[ ":$PATH:" == *":$install_dir:"* ]]; then
        echo -e "  \\e[32m✔\\e[0m Variable de entorno PATH"
    else
        echo -e "  \\e[31m✖\\e[0m Variable de entorno PATH"
        overall_status=1
        error_messages+="[PATH] El directorio '$install_dir' no está en tu PATH. Usa '--setup-path'.\\n"
    fi

    # --- Resumen Final ---
    echo
    if [ "$overall_status" -eq 0 ]; then
        print_success "Verificación completada. ¡Todo en orden!"
    else
        print_warning "Verificación completada con problemas. Detalles:"
        printf "\\n%b\\n" "$error_messages"
    fi
}

function _require_arg() {
    local opt_name="$1"
    local arg_val="$2"
    local arg_name="$3"
    if [ -z "$arg_val" ]; then
        print_error "La opción '$opt_name' requiere un argumento <$arg_name>."
        show_usage
        exit 1
    fi
}


# --- Flujo Principal del Script ---
function main() {

    # Asegurarse de que los directorios de config existen al inicio
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$VERSIONS_DB_DIR"

# --- Procesamiento de Argumentos ---

    # ANTES de procesar argumentos, asegurar que la configuración existe.
    # No se crea la configuración si el script se ejecuta como root (UID 0) para
    # evitar crear archivos de configuración en /root.
        if [ "$(id -u)" -ne 0 ]; then
            ensure_config_exists
            load_config
        fi
    
        if [ $# -eq 0 ]; then
            do_launch
            return
        fi
    
        while [[ $# -gt 0 ]]; do        case "$1" in
            -a|--add) 
                if [[ -n "${2-}" && "${2-}" != -* ]]; then
                    do_add_version "$2"
                    shift 
                else
                    do_add_version
                fi
                exit 0
                ;; 
            -l|--list) 
                do_list_versions
                exit 0
                ;; 
            -d|--remove) 
                _require_arg "$1" "${2-}" "ID de versión"
                do_remove_version "$2"
                exit 0
                ;; 
        -ri|--rename)
            if [ -z "${2-}" ] || [ -z "${3-}" ]; then
                print_error "La opción '--rename' requiere un ID antiguo y uno nuevo."
                exit 1
            fi
            do_rename_id "$2" "$3"
            shift 2
            ;;

            -r|--run) 
                _require_arg "$1" "${2-}" "ID de versión"
                do_run_specific "$2"
                exit 0
                ;; 

            p) # GESTOR DE PLUGINS
                if [ "${2-}" = "--get" ]; then
                    do_plugin_get "${3-}"
                elif [ "${2-}" = "--add" ]; then
                    _require_arg "p --add" "${3-}" "ruta.tar.gz"
                    do_plugin_add "$3"
                elif [ "${2-}" = "--remove" ]; then
                    _require_arg "p --remove" "${3-}" "comando"
                    do_plugin_remove "$3"
                elif [ "${2-}" = "--list" ]; then
                    do_plugin_list
                else
                    # Lógica de ejecución de plugins
                    local plugin_cmd="${2-}"
                    if [ -z "$plugin_cmd" ]; then
                        print_error "Se requiere un comando de plugin."
                        print_info "Uso: $0 p <comando>"
                        exit 1
                    fi

                    local plugins_conf="$CONFIG_DIR/plugins.conf"
                    if [ ! -s "$plugins_conf" ]; then
                        print_error "Plugin '$plugin_cmd' no encontrado. No hay plugins instalados."
                        exit 1
                    fi

                    # Cargar plugins en un array asociativo para búsqueda rápida
                    declare -A plugin_map
                    while IFS=':' read -r command path; do
                        plugin_map["$command"]="$path"
                    done < "$plugins_conf"

                    if [[ -v plugin_map[$plugin_cmd] ]]; then
                        local script_path="${plugin_map[$plugin_cmd]}"
                        # Ejecutar el script del plugin, pasando el resto de argumentos
                        shift 2 # Quitar 'p' y el comando del plugin de la lista de argumentos
                        print_info "Ejecutando plugin '$plugin_cmd'..."
                        "$script_path" "$@"
                    else
                        print_error "Plugin '$plugin_cmd' no encontrado."
                        print_info "Usa '$0 p --list' para ver los plugins disponibles."
                        exit 1
                    fi
                fi
                exit 0
                ;;

            -sd|--set-default) 
                _require_arg "$1" "${2-}" "ID de versión"
                do_set_default_version "$2"
                exit 0
                ;; 
        -cs|--shortcut)
            if [ -z "${2-}" ]; then
                print_error "La opción '--shortcut' requiere un ID de versión."
                exit 1
            fi
            # Comprobar si el siguiente argumento es --icon
            if [ "${3-}" = "--icon" ] || [ "${3-}" = "-ic" ]; then
                if [ -z "${4-}" ]; then
                    print_error "La opción '--icon' requiere una ruta o nombre de archivo."
                    exit 1
                fi
                do_create_shortcut "$2" "$4"
                shift 3
            else
                do_create_shortcut "$2" ""
                shift
            fi
            ;;
            -ad|--add-gui) 
                do_add_gui
                exit 0
                ;; 
            -c|--check) 
                do_check
                exit 0
                ;; 
            -b|--build) 
                do_build
                exit 0
                ;; 
            -cl|--cleanup) 
                do_cleanup_sources
                exit 0
                ;; 
            -u|--uninstall) 
                do_uninstall
                exit 0
                ;; 
                            -us|--uninstall-script)
                                do_uninstall_system
                                exit 0
                                ;;            -h|--help) 
                show_usage
                exit 0
                ;; 
            -i|--interactive) 
                show_interactive_menu
                exit 0
                ;; 
            -in|--install) 
                do_install "$@"
                exit 0
                ;; 
            -id|--install-deps) 
                do_install_deps
                exit 0
                ;; 
            -ic|--install-completion) 
                do_install_completion
                exit 0
                ;; 
            -sp|--setup-path) 
                do_setup_path
                exit 0
                ;; 
            -up|--update) 
                do_update
                exit 0
                ;; 
            # --- NUEVOS COMANDOS DE GESTIÓN DE REPOSITORIOS Y BINARIOS ---
        -gb|--get-binary)
            do_get_binary "${2-}"
            ;;

            -ar|--add-repo)
                _require_arg "$1" "${2-}" "URL"
                do_add_repo "$2"
                exit 0
                ;;
            -rr|--remove-repo)
                _require_arg "$1" "${2-}" "Nombre de Repositorio"
                do_remove_repo "$2"
                exit 0
                ;;
            -lr|--list-repos)
                do_list_repos
                exit 0
                ;;
            -sr|--sync-repos)
                do_sync_repos
                exit 0
                ;;
            -ep|--export) 
                _require_arg "$1" "${2-}" "ruta de salida"
                do_export_precompiled "$2"
                exit 0
                ;; 
            -ip|--import) 
                _require_arg "$1" "${2-}" "ruta de entrada"
                do_import_precompiled "$2"
                exit 0
                ;;
            *)
                print_error "Opción no reconocida: $1"
                show_usage
                exit 1
                ;; 
        esac
        shift # Moverse al siguiente argumento
    done
}

main "$@"