#!/bin/bash

# build_safe.sh
#
# Script mejorado para compilar, gestionar y ejecutar mcpelauncher.
#
# Funcionalidades:
# - Compilar los componentes con manejo seguro del conflicto zlib/zlib-ng.
# - Desinstalar los componentes y limpiar residuos.
# - Añadir y gestionar múltiples versiones del juego.
# - Listar y ejecutar versiones específicas.
# - Ejecutar el juego (acción por defecto).

# --- Configuración de Seguridad y Errores ---
set -e
set -u
set -o pipefail

# --- Variables Globales ---
readonly MCPARCH_ICON_SVG='<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg version="1.1" width="512" height="512" viewBox="0 0 512 512" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><defs id="defs1" /><path id="bg1" fill="#81563a" d="M 0,0 H 512 V 512 H 0 Z" /><path id="bg2" fill="#61b441" d="M 0,0 V 128 H 64 V 64 H 128 V 128 H 256 V 192 H 320 V 128 H 384 V 64 H 448 V 192 H 512 V 0 Z" /><rect id="rect1" width="64" height="64" x="0" y="0" fill="#86d562" /><rect id="rect2" width="64" height="64" x="64" y="0" fill="#52a535" /><rect id="rect3" width="64" height="64" x="128" y="0" fill="#6cc349" /><rect id="rect4" width="64" height="64" x="192" y="0" fill="#86d562" /><rect id="rect5" width="64" height="64" x="256" y="0" fill="#6cc349" /><rect id="rect6" width="64" height="64" x="320" y="0" fill="#52a535" /><rect id="rect7" width="64" height="64" x="384" y="0" fill="#6cc349" /><rect id="rect8" width="64" height="64" x="448" y="0" fill="#52a535" /><rect id="rect9" width="64" height="64" x="0" y="64" fill="#52a535" /><rect id="rect10" width="64" height="64" x="64" y="64" fill="#66412c" /><rect id="rect11" width="64" height="64" x="128" y="64" fill="#52a535" /><rect id="rect12" width="64" height="64" x="192" y="64" fill="#3c8527" /><rect id="rect13" width="64" height="64" x="256" y="64" fill="#52a535" /><rect id="rect14" width="64" height="64" x="320" y="64" fill="#6cc349" /><rect id="rect15" width="64" height="64" x="384" y="64" fill="#66412c" /><rect id="rect16" width="64" height="64" x="448" y="64" fill="#6cc349" /><rect id="rect17" width="64" height="64" x="0" y="128" fill="#66412c" /><rect id="rect18" width="64" height="64" x="64" y="128" fill="#998f8b" /><rect id="rect19" width="64" height="64" x="128" y="128" fill="#66412c" /><rect id="rect20" width="64" height="64" x="192" y="128" fill="#66412c" /><rect id="rect21" width="64" height="64" x="256" y="128" fill="#6cc349" /><rect id="rect22" width="64" height="64" x="320" y="128" fill="#66412c" /><rect id="rect23" width="64" height="64" x="384" y="128" fill="#805539" /><rect id="rect24" width="64" height="64" x="448" y="128" fill="#52a535" /><rect id="rect25" width="64" height="64" x="0" y="192" fill="#976746" /><rect id="rect26" width="64" height="64" x="64" y="192" fill="#805539" /><rect id="rect27" width="64" height="64" x="128" y="192" fill="#976746" /><rect id="rect28" width="64" height="64" x="192" y="192" fill="#ad7a54" /><rect id="rect29" width="64" height="64" x="256" y="192" fill="#66412c" /><rect id="rect30" width="64" height="64" x="320" y="192" fill="#805539" /><rect id="rect31" width="64" height="64" x="384" y="192" fill="#976746" /><rect id="rect32" width="64" height="64" x="448" y="192" fill="#66412c" /><rect id="rect33" width="64" height="64" x="0" y="256" fill="#805539" /><rect id="rect34" width="64" height="64" x="64" y="256" fill="#66412c" /><rect id="rect35" width="64" height="64" x="128" y="256" fill="#66412c" /><rect id="rect36" width="64" height="64" x="192" y="256" fill="#976746" /><rect id="rect37" width="64" height="64" x="256" y="256" fill="#805539" /><rect id="rect38" width="64" height="64" x="320" y="256" fill="#ad7a54" /><rect id="rect39" width="64" height="64" x="384" y="256" fill="#66412c" /><rect id="rect40" width="64" height="64" x="448" y="256" fill="#66412c" /><rect id="rect41" width="64" height="64" x="0" y="320" fill="#ad7a54" /><rect id="rect42" width="64" height="64" x="64" y="320" fill="#805539" /><rect id="rect43" width="64" height="64" x="128" y="320" fill="#66412c" /><rect id="rect44" width="64" height="64" x="192" y="320" fill="#66412c" /><rect id="rect45" width="64" height="64" x="256" y="320" fill="#998f8b" /><rect id="rect46" width="64" height="64" x="320" y="320" fill="#805539" /><rect id="rect47" width="64" height="64" x="384" y="320" fill="#976746" /><rect id="rect48" width="64" height="64" x="448" y="320" fill="#805539" /><rect id="rect49" width="64" height="64" x="0" y="384" fill="#805539" /><rect id="rect50" width="64" height="64" x="64" y="384" fill="#976746" /><rect id="rect51" width="64" height="64" x="128" y="384" fill="#66412c" /><rect id="rect52" width="64" height="64" x="192" y="384" fill="#ad7a54" /><rect id="rect53" width="64" height="64" x="256" y="384" fill="#976746" /><rect id="rect54" width="64" height="64" x="320" y="384" fill="#ad7a54" /><rect id="rect55" width="64" height="64" x="384" y="384" fill="#805539" /><rect id="rect56" width="64" height="64" x="448" y="384" fill="#976746" /><rect id="rect57" width="64" height="64" x="0" y="448" fill="#66412c" /><rect id="rect58" width="64" height="64" x="64" y="448" fill="#805539" /><rect id="rect59" width="64" height="64" x="128" y="448" fill="#998f8b" /><rect id="rect60" width="64" height="64" x="192" y="448" fill="#805539" /><rect id="rect61" width="64" height="64" x="256" y="448" fill="#805539" /><rect id="rect62" width="64" height="64" x="320" y="448" fill="#976746" /><rect id="rect63" width="64" height="64" x="384" y="448" fill="#66412c" /><rect id="rect64" width="64" height="64" x="448" y="448" fill="#ad7a54" /><rect id="rect65" width="64" height="4.4" x="384" y="64" fill="#503120" /><rect id="rect66" width="64" height="4.4" x="320" y="128" fill="#503120" /><rect id="rect67" width="64" height="4.4" x="128" y="128" fill="#503120" /><rect id="rect68" width="64" height="4.4" x="192" y="128" fill="#503120" /><rect id="rect69" width="64" height="4.4" x="64" y="64" fill="#503120" /><rect id="rect70" width="64" height="4.4" x="0" y="128" fill="#503120" /><rect id="rect71" width="64" height="4.4" x="64" y="192" fill="#65402a" /><rect id="rect72" width="64" height="4.4" x="256" y="192" fill="#503120" /><rect id="rect73" width="64" height="4.4" x="448" y="192" fill="#503120" /><rect id="rect74" width="64" height="4.4" x="384" y="256" fill="#503120" /><rect id="rect75" width="64" height="4.4" x="192" y="320" fill="#503120" /><rect id="rect76" width="64" height="4.4" x="128" y="256" fill="#503120" /><rect id="rect77" width="64" height="4.4" x="0" y="256" fill="#65402a" /><rect id="rect78" width="64" height="4.4" x="256" y="384" fill="#764d34" /><rect id="rect79" width="64" height="4.4" x="0" y="448" fill="#503120" /><rect id="rect80" width="64" height="4.4" x="320" y="448" fill="#764d34" /><rect id="rect81" width="64" height="4.4" x="320" y="320" fill="#65402a" /><rect id="rect82" width="64" height="4.4" x="384" y="384" fill="#65402a" /></svg>'
readonly SCRIPT_CWD=$(pwd)
readonly LOG_DIR="$SCRIPT_CWD/logs"
readonly ROOT_SOURCE="$HOME/src"
readonly EXTRACTOR_SRC_DIR="mcpelauncher-extract-src"
readonly LAUNCHER_SRC_DIR="mcpelauncher-src"
readonly ZLIB_BUILD_DIR="$ROOT_SOURCE/zlib_build"
readonly ZLIB_LIB_PATH="$ZLIB_BUILD_DIR/lib/libz.a"
readonly ZLIB_INCLUDE_PATH="$ZLIB_BUILD_DIR/include"

# --- NUEVO: Sistema de gestión de versiones ---
readonly CONFIG_DIR="$HOME/.config/mcparch"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly VERSIONS_DB_DIR="$CONFIG_DIR/versions_db"
GAME_DIR=""

# Variables de configuración (cargadas desde el archivo)
DEFAULT_VERSION_ID=""
CLEANUP_AFTER_BUILD=false


# Variables para desinstalación
readonly LAUNCHER_BUILD_DIR="$ROOT_SOURCE/mcpelauncher-src/build"
readonly EXTRACTOR_BUILD_DIR="$ROOT_SOURCE/mcpelauncher-extract-src/build"
readonly DESKTOP_FILE="$HOME/.local/share/applications/MCPE-LAUNCHER.desktop"
readonly ICON_FILE="$HOME/.local/share/icons/hicolor/scalable/apps/MCPE-LAUNCHER.svg"
readonly GAME_DATA_DIR="$HOME/.local/share/mcpelauncher"


# --- Funciones de Utilidad (Log y Colores) ---
function print_info() {
    echo -e "\e[34m[INFO]\e[0m $1"
}

function print_success() {
    echo -e "\e[32m[SUCCESS]\e[0m $1"
}

function print_warning() {
    echo -e "\e[33m[WARNING]\e[0m $1"
}

function print_error() {
    echo -e "\e[31m[ERROR]\e[0m $1" >&2
}

function run_as_root() {
    # Si ya somos root, simplemente ejecuta el comando.
    if [ "$(id -u)" -eq 0 ]; then
        "$@"
        return
    fi

    # Usar sudo para obtener privilegios, ya que preserva el directorio de trabajo.
    if command -v sudo &> /dev/null; then
        # Verificar si ya tenemos privilegios de sudo cacheados.
        if sudo -n true 2>/dev/null; then
            sudo "$@"
        else
            # Si no, pedimos la contraseña explícitamente en la terminal.
            print_info "Se requieren privilegios de administrador para continuar."
            sudo -v # Pide la contraseña y la cachea.
            if [ $? -ne 0 ]; then
                print_error "No se pudieron obtener los privilegios de root. Abortando."
                exit 1
            fi
            sudo "$@"
        fi
        return
    fi

    # Si no se encuentra sudo.
    print_error "No se encontró 'sudo'. Se necesitan privilegios de administrador."
    exit 1
}

# --- NUEVO: Función HÍBRIDA para verificar el PATH y advertir al usuario ---
function check_path_and_warn() {
    local install_dir="/usr/local/bin"

    # 1. Comprobación del PATH en vivo
    if [[ ":$PATH:" == *":$install_dir:"* ]]; then
        return # El PATH está activo en esta sesión, no se necesita advertencia.
    fi

    # 2. Comprobación del archivo de configuración si el PATH no está en vivo
    local shell_config_file=""
    local path_line_pattern=""
    local shell_name
    shell_name=$(basename "$SHELL")

    case "$shell_name" in
        bash)
            shell_config_file="$HOME/.bashrc"
            path_line_pattern="export PATH=.*$install_dir"
            ;;
        zsh)
            shell_config_file="$HOME/.zshrc"
            path_line_pattern="export PATH=.*$install_dir"
            ;;
        fish)
            shell_config_file="$HOME/.config/fish/config.fish"
            path_line_pattern="fish_add_path $install_dir"
            ;;
        *)
            # Para shells desconocidos, no podemos comprobar el archivo de config.
            # Saltamos directamente a la advertencia genérica.
            shell_config_file=""
            ;;
    esac

    # Si tenemos un archivo de config, lo revisamos
    if [ -n "$shell_config_file" ] && [ -f "$shell_config_file" ]; then
        if grep -q -E "$path_line_pattern" "$shell_config_file"; then
            # La configuración existe, pero no está activa. El usuario solo necesita reiniciar el shell.
            echo
            print_warning "El directorio de instalación '$install_dir' está en tu '$shell_config_file' pero no en el PATH de esta sesión."
            print_info "Esto puede pasar si acabas de instalar. Simplemente reinicia tu terminal para aplicar los cambios."
            echo
            return
        fi
    fi

    # 3. Si ambas comprobaciones fallan, mostrar la advertencia completa.
    echo
    print_warning "El directorio de instalación '$install_dir' no se encuentra en tu variable de entorno PATH."
    print_info "Esto es común en algunas distribuciones como Void Linux."
    print_info "Para que el lanzador funcione, debes añadir esta ruta a tu shell."
    echo

    print_info "Soluciones recomendadas:"
    echo "1. (Automático) Ejecuta este script con la opción '--setup-path' para que lo configure por ti:"
    echo -e "   \e[32m$0 --setup-path\e[0m"
    echo "2. (Manual) Ejecuta el siguiente comando para añadir la línea a tu configuración:"

    if [ -n "$shell_config_file" ]; then
        local manual_command=""
        if [ "$shell_name" = "fish" ]; then
            manual_command="echo 'fish_add_path $install_dir' >> \"$shell_config_file\""
        else
            manual_command="echo 'export PATH=\"$PATH:$install_dir\"' >> \"$shell_config_file\""
        fi
        echo -e "   \e[33m$manual_command\e[0m"
        echo "   Luego, reinicia tu terminal o ejecuta 'source \"$shell_config_file\"' para aplicar los cambios."
    else
        echo "   Abre manualmente el archivo de configuración de tu shell (ej: ~/.profile, ~/.bash_profile)."
        echo "   Añade la siguiente línea al final del archivo:"
        echo -e "   \e[32mexport PATH=\"$PATH:$install_dir\"\e[0m"
        echo "   Luego, reinicia tu terminal para aplicar los cambios."
    fi
    echo
}



function check_dependencies() {
    print_info "Verificando dependencias de compilación..."
    # pkg-config es crucial para encontrar librerías
    local required_cmds=("git" "cmake" "make" "clang" "curl" "pkg-config")
    local required_libs=("libzip" "openssl" "Qt5WebChannel" "Qt5Positioning" "xi") # Librerías a verificar con pkg-config
    local missing_deps=()

    for cmd in "${required_cmds[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    # Solo verificar librerías si pkg-config está instalado
    if command -v "pkg-config" &> /dev/null; then
        for lib in "${required_libs[@]}"; do
            if ! pkg-config --exists "$lib"; then
                # El nombre del paquete de desarrollo suele ser diferente
                # Se informa al usuario del paquete conceptual que falta
                missing_deps+=("$lib-devel")
            fi
        done
    fi

    if [ ${#missing_deps[@]} -eq 0 ]; then
        print_success "Todas las dependencias de compilación están presentes."
        return 0
    fi

    print_error "Faltan dependencias de compilación esenciales: ${missing_deps[*]}"
    print_info "Por favor, instala estas herramientas usando el gestor de paquetes de tu sistema."
    print_info "Si no estás seguro de cómo hacerlo, puedes usar la opción '--install-deps' para que este script intente hacerlo por ti."
    exit 1
}

function do_install_deps() {
    print_info "Intentando instalar dependencias de compilación automáticamente..."

    local PKG_MANAGER=""
    if command -v pacman &> /dev/null; then PKG_MANAGER="pacman";
    elif command -v apt-get &> /dev/null; then PKG_MANAGER="apt";
    elif command -v dnf &> /dev/null; then PKG_MANAGER="dnf";
    elif command -v xbps-install &> /dev/null; then PKG_MANAGER="xbps";
    elif command -v zypper &> /dev/null; then PKG_MANAGER="zypper";
    else
        print_error "No se pudo detectar un gestor de paquetes compatible (apt, pacman, dnf, xbps, zypper)."
        print_error "Por favor, instala manualmente las dependencias completas."
        exit 1
    fi

    print_info "Gestor de paquetes detectado: $PKG_MANAGER"

    local packages=""
    case "$PKG_MANAGER" in
        pacman)
            print_info "En sistemas Arch, se recomienda tener 'base-devel' instalado."
            packages="base-devel git cmake make clang curl pkg-config libzip qt5-base qt5-webengine qt5-location qt5-declarative qt5-quickcontrols2 ca-certificates libpng libx11 libxi systemd libevdev mesa alsa-lib libpulse libxtst openssl qt5-svg"
            ;;
        apt)
            packages="build-essential git cmake make clang curl pkg-config libzip-dev ca-certificates libc6-dev libpng-dev libx11-dev libxi-dev libcurl4-openssl-dev libsystemd-dev libevdev-dev libegl1-mesa-dev libasound2-dev libpulse-dev libxtst-dev libssl-dev qtbase5-dev qtwebengine5-dev qtdeclarative5-dev libqt5svg5-dev qtquickcontrols2-5-dev libqt5quickcontrols2-5 qttools5-dev-tools libudev-dev libstdc++-12-dev qml-module-qtquick-controls qml-module-qtquick-layouts qml-module-qtquick-dialogs qml-module-qtquick-window2 qml-module-qtwebengine qml-module-org-kde-qqc2desktopstyle"
            ;;
        dnf)
            print_info "En sistemas Fedora, se recomienda el grupo 'Development Tools'."
            packages="git cmake make clang curl pkg-config libzip-devel ca-certificates libstdc++ glibc-devel libpng-devel libX11-devel libXi-devel libcurl-devel systemd-devel libevdev-devel mesa-libEGL-devel alsa-lib-devel pulseaudio-libs-devel mesa-dri-drivers libXtst-devel openssl-devel qt5-qtbase-devel qt5-qtwebengine-devel qt5-qtdeclarative-devel qt5-qtsvg-devel qt5-qtquickcontrols qt5-qtquickcontrols2"
            ;;
        xbps)
            # La lista de xbps ya era bastante completa, la mantenemos y aseguramos que no falte nada clave.
            packages="git cmake make clang curl pkg-config libzip-devel openssl-devel libX11-devel wayland-devel alsa-lib-devel libXext-devel libXi-devel libpng-devel MesaLib-devel libevdev-devel qt5-devel qt5-webengine-devel qt5-webchannel-devel qt5-location-devel qt5-declarative-devel qt5-quickcontrols2-devel libatomic-devel"
            ;;
        zypper)
            # Lista similar a DNF para OpenSUSE
            packages="git cmake make clang curl pkg-config libzip-devel ca-certificates libstdc++6-devel glibc-devel libpng16-devel libX11-devel libXi-devel libcurl-devel systemd-devel libevdev-devel Mesa-libEGL1-devel alsa-devel pulseaudio-devel libXtst-devel libopenssl-devel"
            ;;
        *)
            # Fallback genérico
            packages="git cmake make clang curl pkg-config"
            ;;
    esac

    local install_command=""
    case "$PKG_MANAGER" in
        pacman) install_command="sudo pacman -S --noconfirm --needed $packages" ;;
        apt) install_command="sudo apt-get install -y $packages" ;;
        dnf) install_command="sudo dnf install -y $packages" ;;
        xbps) install_command="sudo xbps-install -S -y $packages" ;;
        zypper) install_command="sudo zypper install -y $packages" ;;
    esac

    echo
    print_info "Se ejecutará el siguiente comando:"
    echo "  $install_command"
    echo
    read -p "¿Deseas continuar? (s/n): " choice
    case "$choice" in
        [Ss]*)
            print_info "Instalando dependencias..."
            if eval "$install_command"; then
                print_success "Dependencias instaladas correctamente."
                print_info "Puedes proceder a compilar con la opción '--build'."
            else
                print_error "La instalación de dependencias falló."
                print_error "Por favor, revisa los errores e inténtalo manually."
                exit 1
            fi
            ;;
        *)
            print_error "Instalación cancelada por el usuario."
            exit 1
            ;;
    esac
}

function compile_static_zlib() {
    if [ -f "$ZLIB_LIB_PATH" ]; then
        print_success "Librería zlib estática ya compilada. Omitiendo."
        return
    fi

    print_info "Compilando zlib estático para evitar conflictos con zlib-ng..."
    mkdir -p "$ZLIB_BUILD_DIR"
    cd "$ROOT_SOURCE"

    local zlib_ver="1.3.1"
    local zlib_tar="zlib-${zlib_ver}.tar.gz"
    local zlib_src_dir="zlib-${zlib_ver}"

    if [ ! -f "$zlib_tar" ]; then
        print_info "Descargando zlib v${zlib_ver}..."
        curl -L "https://zlib.net/${zlib_tar}" -o "$zlib_tar"
    fi

    if [ -d "$zlib_src_dir" ]; then
        rm -rf "$zlib_src_dir"
    fi

    print_info "Extrayendo zlib..."
    tar -xzf "$zlib_tar"
    cd "$zlib_src_dir"

    print_info "Configurando y compilando zlib (estático)..."
    export CC=clang # Forzar el uso de clang
    ./configure --prefix="$ZLIB_BUILD_DIR" --static &> "$LOG_DIR/zlib_configure.log"
    make &> "$LOG_DIR/zlib_build.log"
    make install &> "$LOG_DIR/zlib_install.log"

    cd "$ROOT_SOURCE"
    print_success "zlib estático compilado e instalado en '$ZLIB_BUILD_DIR'."
}

function patch_cmake_version() {
    print_info "Actualizando la versión mínima de CMake en los archivos CMakeLists.txt..."
    find . -type f -name "CMakeLists.txt" -not -path "./sdl3/*" -not -path "./imgui/*" -exec sed -i 's/cmake_minimum_required *(VERSION *[0-9.]*)/cmake_minimum_required(VERSION 3.5)/g' {} +
    print_success "Versión de CMake actualizada."
}

function compile_extractor() {
    print_info "Verificando instalación de mcpelauncher-extract..."
    if command -v mcpelauncher-extract &> /dev/null; then
        print_success "mcpelauncher-extract ya está instalado. Omitiendo compilación."
        return
    fi

    print_info "Iniciando compilación de mcpelauncher-extract..."
    if [ -d "$EXTRACTOR_SRC_DIR" ]; then
        print_info "Directorio '$EXTRACTOR_SRC_DIR' encontrado. Actualizando..."
        cd "$EXTRACTOR_SRC_DIR"
        git pull &> "$LOG_DIR/extractor_git.log"
    else
        print_info "Clonando mcpelauncher-extract... (ver '$LOG_DIR/extractor_git.log')"
        git clone https://github.com/minecraft-linux/mcpelauncher-extract.git -b ng "$EXTRACTOR_SRC_DIR" &> "$LOG_DIR/extractor_git.log"
        cd "$EXTRACTOR_SRC_DIR"
    fi

    print_info "Configurando con CMake... (ver '$LOG_DIR/extractor_configure.log')"
    cmake -B build -S . -DCMAKE_POLICY_VERSION_MINIMUM=3.5 &> "$LOG_DIR/extractor_configure.log"

    print_info "Compilando... (ver '$LOG_DIR/extractor_build.log')"
    cmake --build build --parallel "$(nproc)" &> "$LOG_DIR/extractor_build.log"

    print_info "Instalando mcpelauncher-extract... (ver '$LOG_DIR/extractor_install.log')"
    run_as_root cmake --install build &> "$LOG_DIR/extractor_install.log"

    # NUEVO: Guardar el manifiesto de instalación para una desinstalación robusta
    local manifest_path="build/install_manifest.txt"
    if [ -f "$manifest_path" ]; then
        cp "$manifest_path" "$CONFIG_DIR/extractor_install_manifest.txt"
        print_info "Manifiesto de instalación para 'extractor' guardado."
    fi

    cd ..
    print_success "mcpelauncher-extract compilado e instalado."
}

function compile_launcher() {
    print_info "Verificando instalación de mcpelauncher-client..."
    if command -v mcpelauncher-client &> /dev/null; then
        print_success "mcpelauncher-client ya está instalado. Omitiendo compilación."
        return
    fi

    compile_static_zlib
    cd "$ROOT_SOURCE"

    print_info "Iniciando compilación de mcpelauncher-client..."
    if [ -d "$LAUNCHER_SRC_DIR" ]; then
        print_info "Directorio '$LAUNCHER_SRC_DIR' encontrado. Actualizando..."
        cd "$LAUNCHER_SRC_DIR"
        git pull --recurse-submodules &> "$LOG_DIR/launcher_git.log"
    else
        print_info "Clonando mcpelauncher-manifest (esto puede tardar)... (ver '$LOG_DIR/launcher_git.log')"
        git clone --recursive https://github.com/minecraft-linux/mcpelauncher-manifest.git "$LAUNCHER_SRC_DIR" &> "$LOG_DIR/launcher_git.log"
        cd "$LAUNCHER_SRC_DIR"
    fi

    patch_cmake_version

    print_info "Configurando con CMake... (ver '$LOG_DIR/launcher_configure.log')"
    cmake -B build -S . \
          -DCMAKE_C_COMPILER=clang \
          -DCMAKE_CXX_COMPILER=clang++ \
          -DCMAKE_BUILD_TYPE=RelWithDebInfo \
          -DENABLE_DEV_PATHS=OFF \
          -DZLIB_LIBRARY="$ZLIB_LIB_PATH" \
          -DZLIB_INCLUDE_DIR="$ZLIB_INCLUDE_PATH" \
          -Wno-dev &> "$LOG_DIR/launcher_configure.log"

    print_info "Compilando (esto puede tardar mucho)... (ver '$LOG_DIR/launcher_build.log')"
    cmake --build build --parallel "$(nproc)" &> "$LOG_DIR/launcher_build.log"

    print_info "Instalando mcpelauncher-client... (ver '$LOG_DIR/launcher_install.log')"
    run_as_root cmake --install build &> "$LOG_DIR/launcher_install.log"

    # NUEVO: Guardar el manifiesto de instalación para una desinstalación robusta
    local manifest_path="build/install_manifest.txt"
    if [ -f "$manifest_path" ]; then
        cp "$manifest_path" "$CONFIG_DIR/launcher_install_manifest.txt"
        print_info "Manifiesto de instalación para 'launcher' guardado."
    fi

    cd ..
    print_success "mcpelauncher-client compilado e instalado."
}


# --- NUEVO: Funciones de Gestión de Versiones ---

function get_apk_path() {
    local apk_path=""
    while true; do
        read -p "Por favor, ingresa la ruta completa al archivo .apk de Minecraft: " apk_path
        if [ -z "$apk_path" ]; then
            print_error "La ruta no puede estar vacía. Intenta de nuevo."
            continue
        fi
        apk_path="${apk_path/#~$HOME}"
        if [ ! -f "$apk_path" ]; then
            print_error "Archivo no encontrado en '$apk_path'. Asegúrate de que la ruta es correcta."
        else
            echo "$apk_path"
            break
        fi
    done
}

function do_add_version() {
    print_info "Añadiendo una nueva versión de Minecraft..."
    # MEJORA: Usar ruta absoluta para no depender del PATH
    local extractor_bin="/usr/local/bin/mcpelauncher-extract"
    if ! [ -x "$extractor_bin" ]; then
        check_path_and_warn # Aún es útil para advertir al usuario
        print_error "Ejecutable '$extractor_bin' no encontrado o no es ejecutable."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        exit 1
    fi

    local apk_path
    apk_path=$(get_apk_path)

    local version_id
    while true; do
        read -p "Ingresa un ID único para esta versión (ej: 1.20.x.x): " version_id
        if [ -z "$version_id" ]; then
            print_error "El ID no puede estar vacío."
            continue
        fi
        if [ -f "$VERSIONS_DB_DIR/$version_id" ]; then
            print_error "El ID '$version_id' ya existe. Por favor, elige otro."
        else
            break
        fi
    done

    local target_dir="$HOME/.local/share/mcpelauncher/versions/$version_id"
    if [ -d "$target_dir" ]; then
        print_warning "El directorio de destino '$target_dir' ya existe."
        read -p "¿Deseas sobreescribirlo? (s/n): " choice
        case "$choice" in
            [Ss]*) rm -rf "$target_dir" ;;
            *) print_info "Operación cancelada."; exit 0 ;;
        esac
    fi

    print_info "Extrayendo archivos a '$target_dir'..."
    mkdir -p "$target_dir"
    # MEJORA: Usar ruta absoluta
    "$extractor_bin" "$apk_path" "$target_dir"

    # Guardar en la base de datos de versiones
    echo "$target_dir" > "$VERSIONS_DB_DIR/$version_id"
    print_success "Versión '$version_id' añadida y registrada correctamente."
}

function do_list_versions() {
    print_info "Versiones de Minecraft disponibles:"
    if [ -z "$(ls -A "$VERSIONS_DB_DIR")" ]; then
        print_warning "No hay versiones instaladas."
        print_info "Usa la opción '--add' para añadir una."
        return 1
    fi

    # Imprimir una lista numerada
    local i=1
    for version_file in "$VERSIONS_DB_DIR"/*; do
        echo "  $i. $(basename "$version_file")"
        i=$((i + 1))
    done
    return 0
}

function ensure_config_exists() {
    if [ ! -f "$CONFIG_FILE" ]; then
        print_info "Creando archivo de configuración por primera vez..."
        echo "# Archivo de configuración para MCPARCH" > "$CONFIG_FILE"
        echo "DEFAULT_VERSION_ID=\"\"" >> "$CONFIG_FILE"
        print_success "Archivo de configuración creado en '$CONFIG_FILE'."
    fi
}

function do_set_default_version() {
    local version_id="$1"
    local version_file="$VERSIONS_DB_DIR/$version_id"

    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    # Usamos sed para reemplazar el valor de forma segura
    sed -i "s/^DEFAULT_VERSION_ID=.*/DEFAULT_VERSION_ID=\"$version_id\"/" "$CONFIG_FILE"
    print_success "Versión por defecto establecida a '$version_id'."
}

function do_remove_version() {
    local version_id="$1"
    local version_db_file="$VERSIONS_DB_DIR/$version_id"

    if [ ! -f "$version_db_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    local game_path
    game_path=$(cat "$version_db_file")

    print_warning "ADVERTENCIA: Estás a punto de eliminar permanentemente la versión '$version_id'."
    print_warning "Esto borrará los datos del juego en '$game_path'."
    read -p "¿Estás seguro de que deseas continuar? (s/n): " choice
    case "$choice" in
        [Ss]*)
            print_info "Eliminando versión '$version_id'..."

            # Eliminar el directorio del juego
            if [ -d "$game_path" ]; then
                rm -rf "$game_path"
                print_success "Directorio de datos del juego eliminado."
            else
                print_warning "No se encontró el directorio de datos del juego. Puede que ya haya sido eliminado."
            fi

            # Eliminar el archivo de la base de datos
            rm -f "$version_db_file"
            print_success "Registro de la versión eliminado."

            # Comprobar si era la versión por defecto
            if [ "$DEFAULT_VERSION_ID" = "$version_id" ]; then
                print_info "La versión eliminada era la predeterminada. Limpiando configuración..."
                sed -i "s/^DEFAULT_VERSION_ID=.*/DEFAULT_VERSION_ID=\"\"/" "$CONFIG_FILE"
                print_success "La versión por defecto ha sido reiniciada."
            fi

            print_success "Versión '$version_id' eliminada correctamente."
            ;;
        *)
            print_info "Operación cancelada."
            ;;
    esac
}


# --- Funciones de Juego (Actualizadas) ---

function run_game() {
    local game_path="$1"
    if [ -z "$game_path" ] || [ ! -d "$game_path" ]; then
        print_error "La ruta del juego no es válida."
        exit 1
    fi
    print_info "Iniciando Minecraft desde '$game_path'..."
    /usr/local/bin/mcpelauncher-client -dg "$game_path" || true
    print_success "El juego se ha cerrado."
}


# --- Funciones de Desinstalación (Sin cambios) ---

function cleanup_desktop_integration() {
    print_info "Eliminando archivos de integración de escritorio..."
    if [ -f "$DESKTOP_FILE" ]; then
        rm -v "$DESKTOP_FILE"
        print_success "Acceso directo eliminado."
    else
        print_info "No se encontró el acceso directo. Omitiendo."
    fi
    if [ -f "$ICON_FILE" ]; then
        rm -v "$ICON_FILE"
        print_success "Icono eliminado."
    else
        print_info "No se encontró el archivo de icono. Omitiendo."
    fi
}

function ask_and_cleanup_dir() {
    local dir_description="$1"
    local dir_path="$2"
    if [ ! -d "$dir_path" ]; then
        return
    fi
    echo
    print_warning "ADVERTENCIA: Estás a punto de eliminar permanentemente los $dir_description."
    read -p "¿Deseas eliminar el directorio '$dir_path'? (s/n): " choice
    case "$choice" in
        [Ss]*)
            print_info "Eliminando '$dir_path'..."
            if rm -rf "$dir_path"; then
                print_success "Directorio de $dir_description eliminado."
            else
                print_error "No se pudo eliminar el directorio '$dir_path'."
            fi
            ;;
        *)
            print_info "Se conservó el directorio de $dir_description."
            ;;
    esac
}

function uninstall_component() {
    local component_name="$1"
    local build_dir="$2"
    local executable_name=""

    # Asignar el nombre del ejecutable según el componente
    if [ "$component_name" = "launcher" ]; then
        executable_name="mcpelauncher-client"
    elif [ "$component_name" = "extractor" ]; then
        executable_name="mcpelauncher-extract"
    else
        print_error "Nombre de componente desconocido: $component_name"
        return 1
    fi

    # 1. Ubicación primaria del manifiesto (método nuevo y robusto)
    local manifest_file="$CONFIG_DIR/${component_name}_install_manifest.txt"
    # 2. Ubicación de fallback (método antiguo)
    local fallback_manifest_file="$build_dir/install_manifest.txt"

    print_info "Buscando manifiesto para '$component_name'..."

    if [ ! -f "$manifest_file" ]; then
        manifest_file="$fallback_manifest_file"
    fi

    if [ -f "$manifest_file" ]; then
        print_info "Manifiesto encontrado en '$manifest_file'. Desinstalando '$component_name'..."
        if xargs -a "$manifest_file" sudo rm -v; then
            print_success "Archivos de '$component_name' eliminados."
            rm -f "$CONFIG_DIR/${component_name}_install_manifest.txt"
        else
            print_error "Ocurrió un error al eliminar los archivos de '$component_name'."
        fi
    else
        # NUEVA LÓGICA: Si no hay manifiesto, comprobar si el comando existe
        print_warning "No se encontró el manifiesto de desinstalación."
        if command -v "$executable_name" &> /dev/null; then
            local executable_path
            executable_path=$(command -v "$executable_name")
            print_warning "Sin embargo, el comando '$executable_name' todavía existe en '$executable_path'."
            print_info "Esto puede ocurrir si los directorios de compilación se eliminaron antes de desinstalar."
            print_info "No se puede desinstalar automáticamente de forma segura."
            read -p "¿Deseas eliminar el ejecutable principal '$executable_path' ahora? (s/n): " choice
            case "$choice" in
                [Ss]*)
                    if sudo rm -v "$executable_path"; then
                        print_success "Ejecutable '$executable_name' eliminado."
                        print_info "Es posible que otros archivos (librerías, etc.) aún permanezcan. Una recompilación y posterior desinstalación puede limpiarlos."
                    else
                        print_error "No se pudo eliminar el ejecutable."
                    fi
                    ;;
                *)
                    print_info "No se realizaron cambios. Por favor, elimina los archivos manualmente si lo deseas."
                    ;;
            esac
        else
            print_success "El componente '$component_name' parece no estar instalado."
        fi
    fi
}


# --- Funciones de Flujo Principal (Actualizadas) ---

function setup_environment() {
    print_info "Configurando el entorno de compilación..."
    mkdir -p "$LOG_DIR"
    mkdir -p "$ROOT_SOURCE"
    cd "$ROOT_SOURCE"
    print_success "Entorno listo en '$ROOT_SOURCE'."
}


function show_interactive_menu() {
    while true; do
        echo
        echo "========================="
        echo "  MCPARCH - MENÚ INTERACTIVO"
        echo "========================="
        echo "  1. Jugar a Minecraft"
        echo "  2. Añadir nueva versión (.apk)"
        echo "  3. Eliminar una versión"
        echo "  4. Listar versiones instaladas"
        echo "  5. Compilar / Actualizar componentes"
        echo "  6. Limpiar archivos de compilación"
        echo "  7. Desinstalar todo"
        echo "  8. Salir"
        echo "-------------------------"
        read -p "Elige una opción: " choice

        case "$choice" in
            1) do_launch ;;
            2) do_add_version ;;
            3)
                do_list_versions
                if [ $? -eq 0 ]; then
                    read -p "Ingresa el ID de la versión a eliminar: " version_id_to_remove
                    if [ -n "$version_id_to_remove" ]; then
                        do_remove_version "$version_id_to_remove"
                    else
                        print_error "No se ingresó ningún ID."
                    fi
                fi
                ;;
            4) do_list_versions ;;
            5) do_build ;;
            6) do_cleanup_sources ;;
            7) do_uninstall ;;
            8) print_info "Saliendo..."; exit 0 ;;
            *) print_error "Opción no válida. Intenta de nuevo." ;;
        esac
        echo
        read -p "Presiona Enter para continuar..."
    done
}

function show_usage() {
    echo "Uso: $0 [opción] [argumento]"
    echo
    echo "Opciones de Instalación y Desinstalación:"
    echo "  --install          Instala el script y el autocompletado a nivel de sistema."
    echo "  --uninstall-system Desinstala SOLO el script y el autocompletado del sistema."
    echo "  -u, --uninstall    Realiza una desinstalación COMPLETA (sistema, componentes y datos de usuario)."
    echo
    echo "Opciones Generales:"
    echo "  -b, --build        Clona, compila e instala los componentes de mcpelauncher."
    echo "      --cleanup      Limpia los directorios con el código fuente después de una compilación exitosa."
    echo "  -i, --interactive  Abre el menú interactivo del lanzador."
    echo "      --install-deps Intenta instalar las dependencias de compilación automáticamente."
    echo "      --install-completion Instala el script de autocompletado para tu shell (Bash, Zsh, Fish)."
    echo "      --setup-path, -sp Añade automáticamente el directorio de instalación al PATH del shell."
    echo "      --update       Busca y aplica actualizaciones para este script."
    echo "  -h, --help         Muestra este mensaje de ayuda."
    echo
    echo "Gestión de Versiones:"
    echo "  -a, --add          Añade una nueva versión de Minecraft desde un archivo .apk."
    echo "  -l, --list         Lista todas las versiones de Minecraft instaladas."
    echo "  -d, --remove-version <ID> Elimina una versión específica por su ID."
    echo "  -r, --run <ID>     Ejecuta una versión específica de Minecraft por su ID."
    echo "  --set-default <ID> Establece una versión como predeterminada para ejecutar sin argumentos."
    echo "  --create-shortcut <ID> Crea un acceso directo en el menú de aplicaciones."
    echo
    echo "Comportamiento por defecto:"
    echo "  Si no se proporciona ninguna opción, el script intentará ejecutar la versión por defecto o"
    echo "  iniciará el juego de forma interactiva si hay varias versiones y ninguna es la predeterminada."
}

function do_build() {
    print_info "Iniciando proceso de compilación completo..."
    setup_environment
    check_dependencies
    compile_extractor
    compile_launcher
    print_success "¡Proceso de compilación completado!"
    print_info "Todos los componentes necesarios están instalados."

    check_path_and_warn # <--- LLAMADA A LA NUEVA FUNCIÓN

    if [ "$CLEANUP_AFTER_BUILD" = true ]; then
        do_cleanup_sources
    fi
}

function do_update() {
    print_info "Buscando actualizaciones para mcparch..."

    # MEJORA: Asegurarse de que estamos en un repositorio de Git
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        print_error "Esta función solo se puede ejecutar desde el directorio del proyecto clonado con Git."
        exit 1
    fi

    # NUEVO: Comprobar si hay cambios locales sin guardar
    if ! git diff-index --quiet HEAD --; then
        print_error "Tienes cambios locales sin guardar (uncommitted changes)."
        print_warning "Por favor, guarda tus cambios (con 'git commit' o 'git stash') antes de actualizar."
        exit 1
    fi

    # MEJORA: Obtener el nombre de la rama principal de forma más segura
    local main_branch
    if ! main_branch=$(git symbolic-ref --short HEAD 2>/dev/null); then
        print_error "No se pudo determinar la rama actual. Estás en un estado 'detached HEAD'."
        print_warning "Por favor, muévete a una rama (ej: 'git checkout main') para actualizar."
        exit 1
    fi

    print_info "Contactando con el repositorio remoto..."
    if ! git fetch origin; then
        print_error "No se pudo contactar con el repositorio remoto. Verifica tu conexión a internet."
        exit 1
    fi

    # MEJORA: Usar git describe para obtener versiones legibles
    local local_version
    local_version=$(git describe --tags --always --dirty=-modified)
    local remote_version
    remote_version=$(git describe --tags --always "origin/$main_branch")

    # MEJORA: Comparar los commits reales para más fiabilidad
    local local_commit
    local_commit=$(git rev-parse HEAD)
    local remote_commit
    remote_commit=$(git rev-parse "origin/$main_branch")

    if [ "$local_commit" = "$remote_commit" ]; then
        print_success "¡Ya estás en la última versión: $local_version!"
        exit 0
    fi

    # NUEVO: Lógica mejorada para comparar versiones
    local base_commit
    base_commit=$(git merge-base HEAD "origin/$main_branch")

    if [ "$base_commit" = "$remote_commit" ]; then
        print_success "Estás por delante de la versión remota. Tienes commits locales que no se han subido."
        print_info "  Tu versión: $local_version"
        print_info "  Versión remota: $remote_version"
        print_info "Usa 'git push' para publicar tus cambios."
        exit 0
    fi

    if [ "$base_commit" != "$local_commit" ]; then
        print_warning "Tu rama local y la rama remota han divergido."
        print_info "La actualización forzará tu copia local para que coincida con la remota, descartando tus cambios."
    fi

    print_info "¡Hay una nueva versión disponible!"
    print_info "  Versión actual: $local_version"
    print_info "  Nueva versión:  $remote_version"
    echo
    print_info "Cambios:"
    echo "--------------------------------------------------"
    git --no-pager log --pretty=format:"- %s (por %an, %ar)" "$local_commit..$remote_commit"
    echo "--------------------------------------------------"

    read -p "¿Deseas actualizar ahora? (s/n): " choice
    case "$choice" in
        [Ss]*)
            print_info "Actualizando el script de forma forzada (git reset --hard)..."
            if ! git reset --hard "origin/$main_branch"; then
                print_error "La actualización falló. Por favor, revisa los errores de Git."
                exit 1
            fi

            local new_version
            new_version=$(git describe --tags --always)
            print_success "El script ha sido actualizado a la versión $new_version."

            if command -v mcparch &> /dev/null; then
                read -p "¿Deseas reinstalar la nueva versión en el sistema? (s/n): " reinstall_choice
                case "$reinstall_choice" in
                    [Ss]*)
                        if [ "$(id -u)" -ne 0 ]; then
                            print_info "Se necesitan privilegios de root para reinstalar."
                            sudo -- "$0" --install
                        else
                            do_install
                        fi
                        print_success "¡mcparch ha sido reinstalado en el sistema!"
                        ;;
                    *)
                        print_info "No se reinstalará en el sistema. Puedes hacerlo manualmente con '--install'."
                        ;;
                esac
            fi
            ;;
        *)
            print_info "Actualización cancelada."
            ;;
    esac
}

function do_cleanup_sources() {
    print_info "Limpiando los directorios de código fuente..."
    if [ -d "$ROOT_SOURCE" ]; then
        rm -rf "$ROOT_SOURCE"
        print_success "Directorios de compilación eliminados."
    else
        print_warning "El directorio de código fuente '$ROOT_SOURCE' no existe. No hay nada que limpiar."
    fi
}

function do_install() {
    # Asegurarse de que se ejecuta como root
    if [ "$(id -u)" -ne 0 ]; then
        print_info "Se requieren privilegios de superusuario para la instalación."
        # Vuelve a ejecutar el script con sudo y los mismos argumentos
        sudo -- "$0" "$@"
        exit $?
    fi

    print_info "Iniciando la instalación de mcparch a nivel de sistema..."

    local script_path
    script_path=$(realpath "$0")
    local script_dir
    script_dir=$(dirname "$script_path")

    # Variables de instalación
    local install_dir="/usr/local/bin"
    local executable_name="mcparch"
    local bash_completion_dir="/etc/bash_completion.d"
    local fish_completion_dir="/usr/share/fish/completions"

    # 1. Instalar el ejecutable
    print_info "Instalando '$executable_name' en '$install_dir'..."
    cp "$script_path" "$install_dir/$executable_name"
    chmod +x "$install_dir/$executable_name"
    print_success "Script principal instalado."

    # 2. Instalar autocompletado para Bash
    if [ -f "$script_dir/mcparch-completion.bash" ]; then
        print_info "Instalando autocompletado para Bash..."
        mkdir -p "$bash_completion_dir"
        cp "$script_dir/mcparch-completion.bash" "$bash_completion_dir/mcparch"
        print_success "Autocompletado para Bash instalado."
    fi

    # 3. Instalar autocompletado para Fish
    if [ -f "$script_dir/mcparch-completion.fish" ]; then
        print_info "Instalando autocompletado para Fish..."
        mkdir -p "$fish_completion_dir"
        cp "$script_dir/mcparch-completion.fish" "$fish_completion_dir/mcparch.fish"
        print_success "Autocompletado para Fish instalado."
    fi

    echo
    print_success "¡Instalación de MCPARCH completada!"
    print_info "Ahora puedes usar el comando 'mcparch' desde cualquier lugar."
    print_info "Por favor, reinicia tu terminal para que el autocompletado funcione."
    exit 0
}

function do_uninstall_system() {
    # Asegurarse de que se ejecuta como root
    if [ "$(id -u)" -ne 0 ]; then
        print_info "Se requieren privilegios de superusuario para la desinstalación."
        sudo -- "$0" "--internal-uninstall-system"
        return $?
    fi

    print_info "Desinstalando mcparch del sistema..."

    # Archivos a eliminar
    local executable_file="/usr/local/bin/mcparch"
    local bash_completion_file="/etc/bash_completion.d/mcparch"
    local fish_completion_file="/usr/share/fish/completions/mcparch.fish"

    if [ -f "$executable_file" ]; then
        rm -v "$executable_file"
        print_success "Ejecutable del sistema eliminado."
    else
        print_info "El ejecutable del sistema no fue encontrado."
    fi

    if [ -f "$bash_completion_file" ]; then
        rm -v "$bash_completion_file"
        print_success "Autocompletado de Bash eliminado."
    fi

    if [ -f "$fish_completion_file" ]; then
        rm -v "$fish_completion_file"
        print_success "Autocompletado de Fish eliminado."
    fi

    print_success "Desinstalación del sistema completada."
}


function do_uninstall() {
    print_info "Iniciando el proceso de desinstalación COMPLETO..."

    # Paso 1: Desinstalar los archivos del sistema
    do_uninstall_system

    # Paso 2: Desinstalar componentes de compilación y datos de usuario
    print_info "Continuando con la limpieza de datos de usuario y componentes..."
    if [ "$(id -u)" -eq 0 ]; then
        print_error "La limpieza de datos de usuario no debe ejecutarse como root."
        print_info "Ejecuta el comando sin 'sudo' para completar la limpieza de datos."
        exit 1
    fi
    if ! command -v sudo &> /dev/null; then
        print_error "El comando 'sudo' no se encuentra. Se necesitan privilegios de administrador."
        exit 1
    fi

    uninstall_component "launcher" "$LAUNCHER_BUILD_DIR"
    echo
    uninstall_component "extractor" "$EXTRACTOR_BUILD_DIR"
    echo
    cleanup_desktop_integration
    ask_and_cleanup_dir "datos del juego" "$GAME_DATA_DIR"
    ask_and_cleanup_dir "código fuente" "$ROOT_SOURCE"
    # Limpiar nuestra configuración también
    ask_and_cleanup_dir "configuración de mcparch" "$CONFIG_DIR"
    echo
    print_success "Proceso de desinstalación completado."
}

function do_launch() {
    print_info "Iniciando en modo lanzador..."
    if ! [ -x "/usr/local/bin/mcpelauncher-client" ]; then
        check_path_and_warn # <--- LLAMADA A LA NUEVA FUNCIÓN
        print_error "Comando 'mcpelauncher-client' no encontrado."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        exit 1
    fi

    # Comprobar si hay una versión por defecto
    if [ -n "$DEFAULT_VERSION_ID" ]; then
        local version_file="$VERSIONS_DB_DIR/$DEFAULT_VERSION_ID"
        if [ -f "$version_file" ]; then
            print_info "Iniciando versión por defecto '$DEFAULT_VERSION_ID'..."
            local game_path
            game_path=$(cat "$version_file")
            run_game "$game_path"
            return
        else
            print_warning "La versión por defecto '$DEFAULT_VERSION_ID' no se encontró. Ignorando."
        fi
    fi

    local version_files=("$VERSIONS_DB_DIR"/*)
    local num_versions=${#version_files[@]}

    # Si el directorio está vacío o solo contiene un patron sin expandir
    if [ "$num_versions" -eq 1 ] && [ ! -e "${version_files[0]}" ]; then
        num_versions=0
    fi

    if [ "$num_versions" -eq 0 ]; then
        print_error "No hay ninguna versión de Minecraft instalada."
        print_info "Usa la opción '--add' para añadir tu primera versión."
        exit 1
    elif [ "$num_versions" -eq 1 ]; then
        print_info "Se encontró una única versión. Iniciando automáticamente."
        local game_path
        game_path=$(cat "${version_files[0]}")
        run_game "$game_path"
    else
        print_info "Se encontraron varias versiones. Por favor, elige cuál ejecutar:"
        do_list_versions
        local choice
        read -p "Ingresa el número de la versión que quieres ejecutar: " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$num_versions" ]; then
            local selected_version_file="${version_files[$((choice - 1))]}"
            local game_path
            game_path=$(cat "$selected_version_file")
            run_game "$game_path"
        else
            print_error "Selección no válida."
            exit 1
        fi
    fi
}

function do_run_specific() {
    local version_id="$1"
    local version_file="$VERSIONS_DB_DIR/$version_id"
    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    if ! [ -x "/usr/local/bin/mcpelauncher-client" ]; then
        check_path_and_warn # <--- LLAMADA A LA NUEVA FUNCIÓN
        print_error "Comando 'mcpelauncher-client' no encontrado."
        print_error "Por favor, ejecuta el script con la opción '-b' para compilar los componentes primero."
        exit 1
    fi

    local game_path
    game_path=$(cat "$version_file")
    run_game "$game_path"
}

function install_icon_if_needed() {
    local icon_name="mcparch"
    local icon_dir="$HOME/.local/share/icons/hicolor/scalable/apps"
    local icon_file="$icon_dir/$icon_name.svg"

    if [ -f "$icon_file" ]; then
        return # El icono ya existe
    fi

    print_info "Instalando el icono de la aplicación por primera vez..."
    mkdir -p "$icon_dir"
    echo "$MCPARCH_ICON_SVG" > "$icon_file"

    # Actualizar la caché de iconos (opcional, pero buena práctica)
    if command -v gtk-update-icon-cache &> /dev/null; then
        gtk-update-icon-cache -f -t "$HOME/.local/share/icons/hicolor" || true
    fi
    print_success "Icono instalado en '$icon_file'."
}

function do_create_shortcut() {
    local version_id="$1"
    local version_file="$VERSIONS_DB_DIR/$version_id"
    if [ ! -f "$version_file" ]; then
        print_error "El ID de versión '$version_id' no fue encontrado."
        print_info "Usa '--list' para ver las versiones disponibles."
        exit 1
    fi

    # Asegurarse de que el icono está instalado
    install_icon_if_needed

    local desktop_dir="$HOME/.local/share/applications"
    mkdir -p "$desktop_dir"
    local shortcut_file="$desktop_dir/mcparch-$version_id.desktop"

    # Usar siempre la ruta absoluta para el comando Exec
    local exec_command
    if command -v mcparch &> /dev/null; then
        # Si está instalado, obtener su ruta absoluta
        exec_command=$(command -v mcparch)
    else
        # Si no, usar la ruta absoluta del script actual
        exec_command=$(realpath "$0")
    fi


    print_info "Creando acceso directo para la versión '$version_id'..."

    cat > "$shortcut_file" << EOF
[Desktop Entry]
Version=1.0
Name=Minecraft PE ($version_id)
Comment=Juega a Minecraft Bedrock Edition
Exec="$exec_command" --run "$version_id"
Icon=mcparch
Terminal=false
Type=Application
Categories=Game;
EOF

    # Hacer el archivo ejecutable
    chmod +x "$shortcut_file"

    # MEJORA: Actualizar la base de datos de aplicaciones para que el cambio sea inmediato
    if command -v update-desktop-database &> /dev/null; then
        print_info "Actualizando la base de datos de aplicaciones..."
        update-desktop-database "$desktop_dir"
    fi

    print_success "Acceso directo creado en '$shortcut_file'."
    print_info "Debería aparecer en tu menú de aplicaciones en breve."
}

function do_setup_path() {
    print_info "Configurando el PATH del shell..."

    local shell_name
    shell_name=$(basename "$SHELL")
    local install_dir="/usr/local/bin"

    case "$shell_name" in
        bash|zsh)
            local config_file=""
            if [ "$shell_name" = "bash" ]; then
                config_file="$HOME/.bashrc"
            else
                config_file="$HOME/.zshrc"
            fi

            local export_line="export PATH=\"$PATH:$install_dir\""

            # Comprobar si la línea o una similar ya existe
            if [ -f "$config_file" ] && grep -q -E "export PATH=.*$install_dir" "$config_file"; then
                print_success "El PATH ya está configurado en '$config_file'."
            else
                print_info "Añadiendo '$install_dir' al PATH en '$config_file'..."
                echo -e "\n# Añadido por MCPARCH para mcpelauncher" >> "$config_file"
                echo "$export_line" >> "$config_file"
                print_success "¡Configuración completada!"
                print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para aplicar los cambios."
            fi
            ;;
        fish)
            local config_file="$HOME/.config/fish/config.fish"
            local fish_path_line="fish_add_path $install_dir"

            # Crear el archivo si no existe
            mkdir -p "$(dirname "$config_file")"
            touch "$config_file"

            if grep -qF "$fish_path_line" "$config_file"; then
                print_success "El PATH para Fish ya está configurado."
            else
                print_info "Añadiendo '$install_dir' al PATH de Fish..."
                echo -e "\n# Añadido por MCPARCH para mcpelauncher" >> "$config_file"
                echo "$fish_path_line" >> "$config_file"
                print_success "¡Configuración completada!"
                print_info "Por favor, reinicia tu terminal para aplicar los cambios."
            fi
            ;;
        *)
            print_warning "Shell '$shell_name' no soportado para la configuración automática del PATH."
            print_info "Por favor, añade la siguiente línea a tu archivo de configuración manualmente:"
            echo "  export PATH=\"
$PATH:$install_dir\""
            ;;
    esac
}

function do_install_completion() {
    print_info "Instalando autocompletado para el shell..."

    local shell_name
    shell_name=$(basename "$SHELL")

    local script_dir
    script_dir=$(dirname "$(realpath "$0")")

    case "$shell_name" in
        bash)
            local config_file="$HOME/.bashrc"
            local source_line="source \"$script_dir/mcparch-completion.bash\""
            if grep -qF "$source_line" "$config_file"; then
                print_success "El autocompletado para Bash ya está instalado."
            else
                print_info "Añadiendo autocompletado a '$config_file'..."
                echo -e "\n# Autocompletado para MCPARCH\n$source_line" >> "$config_file"
                print_success "¡Instalación completada!"
                print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para activarlo."
            fi
            ;;
        zsh)
            local config_file="$HOME/.zshrc"
            local source_line="source \"$script_dir/mcparch-completion.bash\""
            local bashcomp_line="autoload -U +X bashcompinit && bashcompinit"

            local needs_bashcomp=false
            if ! grep -q "bashcompinit" "$config_file"; then
                needs_bashcomp=true
            fi

            local needs_source=false
            if ! grep -qF "$source_line" "$config_file"; then
                needs_source=true
            fi

            if ! $needs_bashcomp && ! $needs_source; then
                 print_success "El autocompletado para Zsh ya está instalado."
                 return
            fi

            print_info "Añadiendo autocompletado a '$config_file'..."
            echo -e "\n# Autocompletado para MCPARCH" >> "$config_file"
            if $needs_bashcomp; then
                echo "$bashcomp_line" >> "$config_file"
            fi
            if $needs_source; then
                echo "$source_line" >> "$config_file"
            fi
            print_success "¡Instalación completada!"
            print_info "Por favor, reinicia tu terminal o ejecuta 'source $config_file' para activarlo."
            ;;
        fish)
            local completions_dir="$HOME/.config/fish/completions"
            local target_file="$completions_dir/mcparch.fish"

            if [ -f "$target_file" ]; then
                print_success "El autocompletado para Fish ya está instalado."
                return
            fi

            print_info "Instalando autocompletado para Fish..."
            mkdir -p "$completions_dir"
            cp "$script_dir/mcparch-completion.fish" "$target_file"
            print_success "¡Instalación completada!"
            print_info "Por favor, reinicia tu terminal para activar el autocompletado."
            ;;
        *)
            print_error "Shell '$shell_name' no soportado para la instalación automática."
            print_info "Puedes instalarlo manualmente añadiendo la siguiente línea a tu archivo de configuración:"
            echo "  source \"$script_dir/mcparch-completion.bash\""
            ;;
    esac
}


# --- Flujo Principal del Script ---
function main() {

    # Asegurarse de que los directorios de config existen al inicio
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$VERSIONS_DB_DIR"

    # Cargar configuración
    ensure_config_exists
    source "$CONFIG_FILE"

    # --- NUEVO: Procesamiento de argumentos en dos fases ---
    # Fase 1: Leer todos los argumentos y establecer flags.
    local _action_build=false
    local _action_setup_path=false

    if [ $# -eq 0 ]; then
        do_launch
        exit 0
    fi

    # Manejo de un caso interno para la re-ejecución con sudo
    if [ "${1-}" = "--internal-uninstall-system" ]; then
        do_uninstall_system
        exit $?
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--add)
                do_add_version
                exit 0
                ;;
            -l|--list)
                do_list_versions
                exit 0
                ;;
            -d|--remove-version)
                if [ -z "${2-}" ]; then
                    print_error "La opción '--remove-version' requiere un ID de versión como argumento."
                    exit 1
                fi
                do_remove_version "$2"
                exit 0
                ;;
            -r|--run)
                if [ -z "${2-}" ]; then
                    print_error "La opción '--run' requiere un ID de versión como argumento."
                    exit 1
                fi
                do_run_specific "$2"
                exit 0
                ;;
            --set-default)
                if [ -z "${2-}" ]; then
                    print_error "La opción '--set-default' requiere un ID de versión como argumento."
                    exit 1
                fi
                do_set_default_version "$2"
                exit 0
                ;;
            --create-shortcut)
                if [ -z "${2-}" ]; then
                    print_error "La opción '--create-shortcut' requiere un ID de versión como argumento."
                    exit 1
                fi
                do_create_shortcut "$2"
                exit 0
                ;;
            -b|--build)
                _action_build=true # Solo marcamos la acción
                shift
                ;;
            --cleanup)
                CLEANUP_AFTER_BUILD=true # Marcamos la opción de limpieza
                shift
                ;;
            -u|--uninstall)
                do_uninstall
                exit 0
                ;;
            --uninstall-system)
                do_uninstall_system
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -i|--interactive)
                show_interactive_menu
                exit 0
                ;;
            --install)
                do_install "$@"
                exit 0
                ;;
            --install-deps)
                do_install_deps
                exit 0
                ;;
            --install-completion)
                do_install_completion
                exit 0
                ;;
            -sp|--setup-path)
                _action_setup_path=true
                shift
                ;;
            --update)
                do_update
                exit 0
                ;;
            *)
                print_error "Opción no reconocida: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Fase 2: Ejecutar las acciones marcadas.
    if [ "$_action_build" = true ]; then
        do_build
    fi

    if [ "$_action_setup_path" = true ]; then
        do_setup_path
    fi

    if [ "$_action_build" = false ] && [ "$_action_setup_path" = false ] && [ "$CLEANUP_AFTER_BUILD" = true ]; then
        # Solo ejecutar cleanup si no se hizo build y se pasó --cleanup
        do_cleanup_sources
    elif [ "$_action_build" = true ] && [ "$CLEANUP_AFTER_BUILD" = true ]; then
        # do_build ya se encarga de esto, no hacer nada extra
        :
    elif [ "$CLEANUP_AFTER_BUILD" = true ]; then
        # Caso para --setup-path --cleanup
        do_cleanup_sources
    fi
}

main "$@"
